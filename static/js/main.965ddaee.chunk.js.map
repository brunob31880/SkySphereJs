{"version":3,"sources":["components/Grid.js","components/Horizon.js","utils/unitUtils.js","utils/astroUtils.js","contexts/Skycontext.js","CameraControls.js","components/Stars.js","components/Constellations.js","components/Sky.js","components/SkyDome.js","ErrorBoundary.js","components/Sidebar.js","components/Header.js","App.js","index.js"],"names":["Grid","group","useRef","useEffect","dashMaterialRA","THREE","color","dashSize","gapSize","dashMaterialDEC","createCircleGeometry","radius","geometry","positions","Float32Array","i","theta","Math","PI","cos","sin","setAttribute","load","font","ra","circGeom","rotateZ","degToRad","rotateY","circ","computeLineDistances","layers","set","current","add","textGeom","String","size","height","curveSegments","bevelEnabled","textMaterial","textMesh","position","x","z","y","lookAt","dec","translateY","_jsx","ref","Horizon","meshRef","renderOrder","_jsxs","rotation","children","attach","args","side","transparent","opacity","depthWrite","degrees","hmsToRad","hours","minutes","seconds","hmsToDeg","dmsToRad","dmsToDeg","radToDeg","angleInRadians","equatorialToHorizontal","H","latitude","decRad","HRad","latRad","h","asin","azimuth","atan2","altitude","getIntersectionWithSphere","rayOrigin","rayDirection","sphereCenter","sphereRadius","oc","subVectors","a","dot","b","discriminant","t1","sqrt","t2","t","SkyContext","React","createContext","SkyProvider","_ref","_ref4","_useState","useState","_useState2","_slicedToArray","isDebugEnabled","setIsDebugEnabled","_useState3","alpha","beta","gamma","_useState4","setOrientation","_useState5","_useState6","representation","setRepresentation","_useState7","_useState8","shownConstellations","setShownConstellations","_useState9","Date","_useState10","currentTime","setCurrentTime","_useState11","longitude","_useState12","location","setLocation","_useState13","_useState14","starsData","setStarsData","_useState15","_useState16","horizontalCoords","setHorizontalCoords","_useState17","_useState18","hipToIndex","_useState19","_useState20","maxShownMagnitude","setMaxShownMagnitude","_useState21","_useState22","constellationLines","setConstellationLines","_useState23","_useState24","isLoaded","setIsLoaded","R","navigator","geolocation","getCurrentPosition","coords","fetch","concat","then","response","json","data","cityName","address","city","town","village","catch","error","console","handleOrientation","event","window","addEventListener","removeEventListener","interval","setInterval","clearInterval","log","time","minAzimuth","Infinity","maxAzimuth","minAltitude","maxAltitude","newAltAzArray","newHorizontalCoords","raDec","forEach","LST","GST","UTC","getSiderealTime","raInDegrees","decInDegrees","hourAngle","lst","calculateHourAngle","_equatorialToHorizont","push","timeEnd","_objectSpread","altAzArray","Promise","all","process","text","_ref2","_ref3","starsDataText","constellationLinesText","idents","abbrevs","minRA","maxRA","minDEC","maxDEC","lines","split","filter","line","startsWith","trim","hipparcosIds","newMagnitudes","raDecArray","presentHips","map","parseInt","sort","missingHips","Array","from","length","_","hip","includes","index","parts","hipNumber","raParts","part","parseFloat","decParts","apply","_toConsumableArray","mag","isNaN","Error","validMagnitudes","minMagnitude","min","maxMagnitude","max","identStars","starName","substring","endsWith","slice","_defineProperty","vertices","magnitudes","abbreviationToName","fullName","description","parsedLines","abbreviation","abbreviationGroup","startStar","endStar","Provider","value","toggleShownConstellations","toggleRepresentation","CameraControls","previousMousePosition","setPreviousMousePosition","isMouseDown","setIsMouseDown","_useContext","useContext","_useThree","useThree","camera","gl","handleMouseMove","deltaX","offsetX","deltaY","offsetY","abs","horizontalRotation","setFromAxisAngle","quaternion","multiply","verticalRotation","canvas","domElement","handleWheel","zoomChange","sign","mouse","clientWidth","clientHeight","raycaster","setFromCamera","intersectionPoint","ray","direction","normalize","zoom","clamp","updateProjectionMatrix","handleKeyDown","rotationAngle","code","rotateOnAxis","enable","handleMouseDown","button","handleMouseUp","viewDirection","getWorldDirection","offset","multiplyScalar","htmlPosition","addVectors","_Fragment","Html","toArray","style","top","left","display","flexDirection","gap","width","toFixed","Stars","scene","highlightedTextSpriteRef","starGroupRef","highlightedStarRef","linePrecision","rayHelperRef","removeDebugRay","remove","highlightStar","star","circleGeometry","circleMaterial","circle","starPosition","object","attributes","vertex","fromBufferAttribute","copy","_starsData$altAzArray","_starsData$raDec$star","textSprite","texture","spriteMaterial","sprite","scale","createTextSprite","document","createElement","ctx","getContext","fillStyle","fillText","replace","createTextTexture","shaderMaterial","uniforms","starTexture","gradient","createRadialGradient","addColorStop","fillRect","needsUpdate","createStarTexture","vertexShader","fragmentShader","depthTest","blending","points","key","prev","onClick","closestStarIndex","minDistance","setDirection","origin","starPositions","distance","distanceTo","hipparcosId","Constellations","constellationGroupRef","context","textWidth","measureText","textHeight","textAlign","textBaseline","child","material","barycenters","startStarIndex","endStarIndex","startStarCoords","endStarCoords","setFromPoints","lineObj","sum","count","barycenter","divideScalar","textTexture","clone","Sky","SkyDome","Spinner","justifyContent","alignItems","border","borderRadius","borderTop","animation","Canvas","background","right","bottom","near","far","intensity","ErrorBoundary","_Component","_inherits","_super","_createSuper","props","_this","_classCallCheck","call","state","hasError","errorInfo","_createClass","this","setState","whiteSpace","toString","componentStack","Component","Sidebar","sliderValue","setSliderValue","className","type","step","onChange","newMagnitude","target","Header","deviceType","offsetHours","getTimezoneOffset","toLocaleTimeString","App","getDeviceType","innerWidth","setDeviceType","handleResize","ReactDOM","createRoot","getElementById","render","StrictMode"],"mappings":"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","file":"static/js/main.965ddaee.chunk.js","sourcesContent":["import React, { useRef, useEffect } from 'react';\nimport * as THREE from 'three';\n\nfunction Grid() {\n    const group = useRef();\n\n    useEffect(() => {\n        const segments = 64;\n        const numDivisions = 36;  // Par exemple, pour 36 divisions\n        const increment = 360 / numDivisions;\n\n        const dashMaterialRA = new THREE.LineDashedMaterial({\n            color: 0x684f4f,\n            dashSize: 10,\n            gapSize: 5\n        });\n\n        const dashMaterialDEC = new THREE.LineDashedMaterial({\n            color: 0x684f4f,\n            dashSize: 10,\n            gapSize: 5\n        });\n\n        const createCircleGeometry = (radius) => {\n            const geometry = new THREE.BufferGeometry();\n            const positions = new Float32Array((segments + 1) * 3);\n\n            for (let i = 0; i <= segments; i++) {\n                const theta = (i / segments) * Math.PI * 2;\n                positions[i * 3] = radius * Math.cos(theta);\n                positions[i * 3 + 1] = 0;\n                positions[i * 3 + 2] = radius * Math.sin(theta);\n            }\n\n            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n            return geometry;\n        };\n        // Étape 1: Chargez une police\n        const fontLoader = new THREE.FontLoader();\n\n        fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {\n            for (let ra = 0; ra < 360; ra += increment) {\n                const circGeom = createCircleGeometry(1000);\n\n                // Tourner le cercle de 90 degrés autour de l'axe Z pour le positionner dans le plan YZ.\n                circGeom.rotateZ(THREE.MathUtils.degToRad(90));\n\n                // Ensuite, tourner la géométrie autour de l'axe Y par ra degrés.\n                circGeom.rotateY(THREE.MathUtils.degToRad(ra));\n\n                const circ = new THREE.Line(circGeom, dashMaterialRA);\n                circ.computeLineDistances();\n                // Pour le raycasting\n                circ.layers.set(1);\n                group.current.add(circ);\n                // Étape 2: Créez une TextGeometry pour chaque valeur de 'ra'\n                const textGeom = new THREE.TextGeometry(String(ra), {\n                    font: font,\n                    size: 40,  // Ajustez selon vos besoins\n                    height: 5, // Ajustez selon vos besoins\n                    curveSegments: 12,\n                    bevelEnabled: false,\n                });\n\n                // Étape 3: Positionnez le texte sur la sphère\n                const textMaterial = new THREE.MeshBasicMaterial({ color: 0x684f4f });  // Couleur du texte, ajustez selon vos besoins\n                const textMesh = new THREE.Mesh(textGeom, textMaterial);\n\n                const radius = 1000;\n                textMesh.position.x = radius * Math.cos(THREE.MathUtils.degToRad(ra));\n                textMesh.position.z = radius * Math.sin(THREE.MathUtils.degToRad(ra));\n                textMesh.position.y = 0;\n\n                textMesh.lookAt(0, 0, 0);  // Faites en sorte que le texte regarde vers le centre de la sphère\n                group.current.add(textMesh);\n            }\n\n\n            for (let dec = -90; dec < 90; dec += increment) {\n                const circGeom = createCircleGeometry(1000 * Math.cos(THREE.MathUtils.degToRad(dec)));\n                const circ = new THREE.Line(circGeom, dashMaterialDEC);\n                circ.translateY(1000 * Math.sin(THREE.MathUtils.degToRad(dec)));\n                circ.computeLineDistances();\n                // Pour le raycasting\n                circ.layers.set(1);\n                group.current.add(circ);\n                // Étape 2: Créez une TextGeometry pour chaque valeur de 'dec'\n                const textGeom = new THREE.TextGeometry(String(dec), {\n                    font: font,\n                    size: 40,  // Taille du texte, ajustez selon vos besoins\n                    height: 5, // Profondeur du texte, ajustez selon vos besoins\n                    curveSegments: 12,\n                    bevelEnabled: false,\n                });\n\n                // Étape 3: Positionnez le texte sur la sphère\n                const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });  // Couleur du texte, ajustez selon vos besoins\n                const textMesh = new THREE.Mesh(textGeom, textMaterial);\n\n                const radius = 1000;\n                textMesh.position.x = radius *  Math.cos(THREE.MathUtils.degToRad(dec));\n                textMesh.position.y = radius * Math.sin(THREE.MathUtils.degToRad(dec));\n                textMesh.position.z = 0\n\n                textMesh.lookAt(0, 0, 0);  // Faites en sorte que le texte regarde vers le centre de la sphère\n                group.current.add(textMesh);\n            }\n\n        })\n    }, []);\n\n    return <group ref={group} />;\n}\n\nexport default Grid;\n","import React,{useRef,useEffect} from 'react';\nimport * as THREE from 'three';\n\nfunction Horizon() {\n    const meshRef = useRef();\n\n    useEffect(() => {\n        if (meshRef.current) {\n            meshRef.current.renderOrder = 1; // Assurez-vous que c'est un numéro plus élevé que les autres objets de votre scène\n        }\n    }, []);\n    const radius=1000;\n    const segments =64;\n    return (\n        <mesh ref={meshRef} rotation={[-Math.PI / 2, 0, 0]}>\n            <ringBufferGeometry attach=\"geometry\" args={[0, radius, segments]} />\n            <meshBasicMaterial \n                attach=\"material\" \n                color={0xffffff} \n                side={THREE.DoubleSide} \n                transparent={true} \n                opacity={0.1}\n                depthWrite={false} // Ajout de cette ligne\n            />\n        </mesh>\n    );\n}\n\nexport default Horizon;\n","const degToRad = (degrees) => {\n    return degrees * (Math.PI / 180);\n}\n\nconst hmsToDeg = (hours, minutes, seconds) => {\n    return 15 * (hours + minutes / 60 + seconds / 3600);\n}\n\nconst dmsToDeg = (degrees, minutes, seconds) => {\n    return degrees + minutes / 60 + seconds / 3600;\n}\n\nconst hmsToRad = (hours, minutes, seconds) => {\n    return degToRad(hmsToDeg(hours, minutes, seconds));\n}\n\nconst dmsToRad = (degrees, minutes, seconds) => {\n    return degToRad(dmsToDeg(degrees, minutes, seconds));\n}\nfunction radToDeg(angleInRadians) {\n    return angleInRadians * (180 / Math.PI);\n}\n\nexport { radToDeg,degToRad, hmsToDeg, dmsToDeg, hmsToRad, dmsToRad };\n","\nimport { degToRad,radToDeg } from \"three/src/math/MathUtils\";\nimport * as THREE from 'three';\n\n/**\n * Calcule le temps sidéral local (LST) pour une longitude donnée.\n * \n * @param {number} longitude - La longitude en degrés pour laquelle le temps sidéral sera calculé.\n * @return {number} Le temps sidéral local (LST) en degrés.\n */\nexport function getSiderealTime(longitude) {\n    // Obtener la date et l'heure actuelles\n    const now = new Date();\n\n    // Calculer le nombre de jours écoulés depuis le début du J2000.0\n    const centuryStart = new Date(Date.UTC(2000, 0, 1, 12)); // 1er janvier 2000, 12h UT\n    const daysSinceJ2000 = (now - centuryStart) / (1000 * 60 * 60 * 24);\n\n    // Calculez le temps sidéral vert (GST) en utilisant une formule simplifiée\n    let GST = 280.16 + 360.9856235 * daysSinceJ2000;\n    GST = GST % 360; // Ramenez-le à l'intervalle [0, 360°]\n\n    // Convertir le GST en temps sidéral local (LST) en ajoutant la longitude\n    let LST = GST + longitude;\n    while (LST < 0) LST += 360;\n    while (LST > 360) LST -= 360;\n\n    return LST;\n}\n\n/**\n * Calcule l'heure angulaire d'un astre en fonction du temps sidéral local et de son ascension droite.\n * \n * @param {number} lst - Le temps sidéral local en degrés.\n * @param {number} ra - L'ascension droite de l'astre en degrés.\n * @return {number} L'heure angulaire en degrés.\n */\nexport function calculateHourAngle(lst, ra) {\n    let H = lst - ra;\n\n    // Ajustement pour s'assurer que H est dans l'intervalle [0, 360°] ou [0, -360°].\n    while (H >= 360) {\n        H -= 360;\n    }\n    while (H < 0) {\n        H += 360;\n    }\n\n    return H;\n}\n\n/**\n * Convertit des coordonnées équatoriales à horizontales.\n * \n * @param {number} dec - La déclinaison de l'astre en degrés.\n * @param {number} H - L'heure angulaire en degrés.\n * @param {number} latitude - La latitude de l'observateur en degrés.\n * @return {object} Un objet contenant les coordonnées horizontales : azimut (en radian) et altitude (en radian).\n */\nexport const equatorialToHorizontal = (dec, H, latitude) => {\n    // Convert all angles to radians\n    const decRad = degToRad(dec);\n    const HRad = degToRad(H);\n    const latRad = degToRad(latitude);\n  \n    // Calculate altitude (h)\n    const h = Math.asin(Math.sin(latRad) * Math.sin(decRad) + Math.cos(latRad) * Math.cos(decRad) * Math.cos(HRad));\n    \n    // Calculate azimuth (A) using the formula you provided\n    const A = Math.atan2(-Math.cos(decRad) * Math.cos(latRad) * Math.sin(HRad), Math.sin(decRad) - Math.sin(latRad) * Math.sin(h));\n  \n\n    return {\n      azimuth: A,\n      altitude: h\n    };\n  };\n\n\n export function getIntersectionWithSphere(rayOrigin, rayDirection, sphereCenter, sphereRadius) {\n    // Calcul des coefficients a, b et c pour l'équation quadratique\n    const oc = new THREE.Vector3().subVectors(rayOrigin, sphereCenter);\n\n    const a = rayDirection.dot(rayDirection);\n    const b = 2.0 * oc.dot(rayDirection);\n    const c = oc.dot(oc) - sphereRadius * sphereRadius;\n\n    const discriminant = b * b - 4 * a * c;\n\n    if (discriminant < 0) {\n        return null; // Pas d'intersection\n    } else {\n        // On utilise t1 comme point d'intersection car c'est le point le plus proche\n        const t1 = (-b - Math.sqrt(discriminant)) / (2.0 * a);\n        const t2 = (-b + Math.sqrt(discriminant)) / (2.0 * a);\n\n        // Si t1 est négatif, alors le début du rayon est à l'intérieur de la sphère\n        const t = t1 > 0 ? t1 : t2;\n\n        return new THREE.Vector3(\n            rayOrigin.x + t * rayDirection.x,\n            rayOrigin.y + t * rayDirection.y,\n            rayOrigin.z + t * rayDirection.z\n        );\n    }\n}","// SkyContext.js\nimport React, { useState, useEffect } from 'react';\nimport { radToDeg, hmsToRad, dmsToRad } from '../utils/unitUtils';\nimport { getSiderealTime, equatorialToHorizontal, calculateHourAngle } from '../utils/astroUtils'\nconst SkyContext = React.createContext();\n/**\n * \n * @param {*} param0 \n * @returns \n */\nfunction SkyProvider({ children }) {\n    const [isDebugEnabled, setIsDebugEnabled] = useState(false);\n    const [orientation, setOrientation] = useState({ alpha: 0, beta: 0, gamma: 0 });\n    const [representation, setRepresentation] = useState(\"Equatorial\");\n    const [shownConstellations, setShownConstellations] = useState(\"Oui\");\n    const [currentTime, setCurrentTime] = useState(new Date());\n    const [location, setLocation] = useState({ latitude: null, longitude: null });\n    const [starsData, setStarsData] = useState(null);\n    const [horizontalCoords, setHorizontalCoords] = useState(null);\n    const [hipToIndex, setHipToIndex] = useState({});\n    const [maxShownMagnitude, setMaxShownMagnitude] = useState(6);\n    const [constellationLines, setConstellationLines] = useState([]);\n    const [isLoaded, setIsLoaded] = useState(false);\n    const R = 1000; // Rayon de la sphère céleste\n\n    const toggleRepresentation = () => {\n        if (representation === 'Equatorial') {\n            setRepresentation('Horizontal');\n        } else {\n            setRepresentation('Equatorial');\n        }\n    };\n\n    const toggleShownConstellations = () => {\n        if (shownConstellations === \"Oui\") {\n            setShownConstellations(\"Non\");\n        } else {\n            setShownConstellations(\"Oui\");\n        }\n    };\n\n    useEffect(() => {\n        if (navigator.geolocation) {\n            navigator.geolocation.getCurrentPosition(position => {\n                const latitude = position.coords.latitude;\n                const longitude = position.coords.longitude;\n    \n                // Utilisez l'API de géocodage inversé de Nominatim pour obtenir le nom de la ville\n                fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}&zoom=10`)\n                    .then(response => response.json())\n                    .then(data => {\n                        const cityName = data.address.city || data.address.town || data.address.village;\n                        setLocation({\n                            latitude: latitude,\n                            longitude: longitude,\n                            cityName: cityName  // Ajoutez le nom de la ville à l'objet location\n                        });\n                    })\n                    .catch(error => {\n                        console.error(\"Erreur lors de la récupération du nom de la ville:\", error);\n                    });\n    \n            }, error => {\n                console.error(\"Erreur de géolocalisation:\", error);\n            });\n        } else {\n            console.error(\"Géolocalisation non supportée par ce navigateur.\");\n        }\n    }, []);\n    \n\n    useEffect(() => {\n        const handleOrientation = (event) => {\n            const { alpha, beta, gamma } = event;\n            setOrientation({ alpha, beta, gamma });\n        };\n    \n        window.addEventListener('deviceorientation', handleOrientation);\n    \n        return () => {\n            // Assurez-vous de retirer l'écouteur d'événements lorsque le composant est démonté\n            window.removeEventListener('deviceorientation', handleOrientation);\n        };\n    }, []);\n    \n    useEffect(() => {\n        const interval = setInterval(() => {\n            setCurrentTime(new Date());\n        }, 1000);\n\n        return () => clearInterval(interval);\n    }, []);\n\n    const parseDMS = (dms) => {\n        const parts = dms.split(/\\s+/);\n        return parts.map(part => parseFloat(part));\n    };\n\n    const parseHMS = (hms) => {\n        const parts = hms.split(/\\s+/);\n        return parts.map(part => parseFloat(part));\n    };\n\n    useEffect(() => {\n        if (starsData && location.latitude && location.longitude) {\n            console.log(\"Calcul des coordonnées horizontales\");\n\n            // Démarrer le chronomètre\n            console.time(\"Calcul des coordonnées horizontales\");\n            let minAzimuth = Infinity;\n            let maxAzimuth = -Infinity;\n            let minAltitude = Infinity;\n            let maxAltitude = -Infinity;\n\n\n            const newAltAzArray = [];\n            const newHorizontalCoords = [];\n\n            starsData.raDec.forEach((raDec) => {\n                const { ra, dec } = raDec;\n                const LST = getSiderealTime(location.longitude);\n                const raInDegrees = radToDeg(ra);\n                const decInDegrees = radToDeg(dec);\n\n                const hourAngle = calculateHourAngle(LST, raInDegrees);\n                const { azimuth, altitude } = equatorialToHorizontal(decInDegrees, hourAngle, location.latitude);\n\n\n\n                // Mettre à jour les valeurs minimales et maximales\n                if (azimuth < minAzimuth) minAzimuth = azimuth;\n                if (azimuth > maxAzimuth) maxAzimuth = azimuth;\n                if (altitude < minAltitude) minAltitude = altitude;\n                if (altitude > maxAltitude) maxAltitude = altitude;\n\n                newAltAzArray.push({ azimuth, altitude }); // Stocker les valeurs d'azimuth et d'altitude\n\n                const x = R * Math.cos(altitude) * Math.cos(azimuth);\n                const z = R * Math.cos(altitude) * Math.sin(azimuth);\n                const y = R * Math.sin(altitude);\n\n                newHorizontalCoords.push(x, y, z);  // Ajouter les coordonnées en séquence\n            });\n\n            // Afficher les valeurs minimales et maximales pour le débogage\n            console.log(\"Azimuth Range:\", minAzimuth, \"-\", maxAzimuth);\n            console.log(\"Altitude Range:\", minAltitude, \"-\", maxAltitude);\n\n            // Arrêter le chronomètre et afficher le temps écoulé\n            console.timeEnd(\"Calcul des coordonnées horizontales\");\n\n            setHorizontalCoords(newHorizontalCoords);\n            setStarsData({\n                ...starsData,\n                horizontalCoords: newHorizontalCoords,\n                altAzArray: newAltAzArray  // Ajouter le nouveau tableau altAzArray au contexte\n            });\n        }\n    }, [isLoaded, location]);\n\n\n\n\n\n\n    useEffect(() => {\n        Promise.all([\n            fetch(`${process.env.PUBLIC_URL}/datas/hip.tsv`).then(response => response.text()),\n            fetch(`${process.env.PUBLIC_URL}/datas/constellation_line_hip.csv`).then(response => response.text()),\n            fetch(`${process.env.PUBLIC_URL}/datas/ident4.csv`).then(response => response.text()),\n            fetch(`${process.env.PUBLIC_URL}/datas/constellation_abbréviations.csv`).then(response => response.text())\n        ]).then(([starsDataText, constellationLinesText, idents, abbrevs]) => {\n            // Logique pour traiter starsDataText et constellationLinesText\n            // Traitement de starsDataText\n            let minRA = Infinity;\n            let maxRA = -Infinity;\n            let minDEC = Infinity;\n            let maxDEC = -Infinity;\n\n            const lines = starsDataText.split('\\n').filter(line => !line.startsWith('#') && line.trim() !== '');\n\n            const coords = [];\n            const hipparcosIds = [];\n            const newMagnitudes = [];\n            const raDecArray = [];\n\n            const RA_INDEX = 1;\n            const DEC_INDEX = 2;\n            const MAG_INDEX = 3;\n\n\n            // Créez une liste de tous les numéros HIP présents dans le fichier\n            const presentHips = lines.map(line => parseInt(line.split('|')[0])).sort((a, b) => a - b);\n\n            // Créez une liste complète de 1 à 118322\n            const allHips = Array.from({ length: 118322 }, (_, i) => i + 1);\n\n            // Trouvez les numéros HIP manquants\n            const missingHips = allHips.filter(hip => !presentHips.includes(hip));\n\n            console.log(\"Missing HIP numbers:\", missingHips);\n\n            lines.forEach((line, index) => {\n                const parts = line.split('|');\n                const hipNumber = parseInt(parts[0], 10);\n                hipToIndex[hipNumber] = index;\n                const raParts = parseHMS(parts[RA_INDEX]);\n                const decParts = parseDMS(parts[DEC_INDEX]);\n\n                const ra = hmsToRad(...raParts);\n                const dec = dmsToRad(...decParts);\n                const mag = parseFloat(parts[MAG_INDEX]);\n\n                if (ra < minRA) minRA = ra;\n                if (ra > maxRA) maxRA = ra;\n                if (dec < minDEC) minDEC = dec;\n                if (dec > maxDEC) maxDEC = dec;\n\n                if (!isNaN(mag)) {\n                    newMagnitudes.push(mag);\n                } else {\n                    console.error(\"Invalid magnitude value:\", parts[MAG_INDEX]);\n                }\n\n                const x = R * Math.cos(dec) * Math.cos(ra);\n                const z = R * Math.cos(dec) * Math.sin(ra);\n                const y = R * Math.sin(dec);\n\n                // pour deboggage affichage de la position de la polaire\n\n                if (hipNumber === 11767) console.log('Etoile polaire: X=' + x + \" Y=\" + y + \" Z=\" + z + \" \");\n                if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {\n                    coords.push(x, y, z);\n                    hipparcosIds.push(hipNumber)\n                    raDecArray.push({ ra, dec });\n                } else {\n                    console.error(\"Problem with HIP=\" + parts[0]);\n                }\n\n                // Vérifier la taille des tableaux de données\n                if ((coords.length / 3) !== newMagnitudes.length) {\n                    console.error(\"Mismatch detected at line index:\", index);\n                    console.error(\"Line content:\", line);\n                    throw new Error(\"Mismatch in data arrays\"); // This will stop further processing\n                }\n            });\n\n\n            console.log(\"Nb étoiles:\" + newMagnitudes.length);\n            console.log(\"RA Range:\", minRA, \"-\", maxRA);\n            console.log(\"DEC Range:\", minDEC, \"-\", maxDEC);\n\n            // Vérifier la gamme de magnitudes\n            const validMagnitudes = newMagnitudes.filter(mag => !isNaN(mag));\n\n            const minMagnitude = Math.min(...validMagnitudes);\n            const maxMagnitude = Math.max(...validMagnitudes);\n            console.log(\"Magnitude Range:\", minMagnitude, \"-\", maxMagnitude);\n\n            const identStars = {};\n\n            // console.log(idents.split('\\n'))\n            const identLines = idents.split('\\n').filter(line => line.trim() !== '');\n            identLines.forEach(line => {\n                const parts = line.split('|');\n                let starName = parts[0].trim();\n                // Retire les guillemets en trop\n                if (starName.startsWith('\"')) {\n                    starName = starName.substring(1);\n                }\n                if (starName.endsWith('\"')) {\n                    starName = starName.substring(0, starName.length - 1);\n                }\n\n                const hipNumber = parseInt(parts[1].trim(), 10);\n\n                if (!isNaN(hipNumber)) {\n                    identStars[hipNumber] = starName;\n                }\n            });\n            console.log(\"Premières valeurs de raDecArray:\", raDecArray.slice(0, 10));\n\n            const starsData = {\n                vertices: coords,\n                magnitudes: newMagnitudes,\n                hipToIndex: hipToIndex,\n                hipparcosIds,\n                identStars,\n                raDec: raDecArray,\n                magnitudes: newMagnitudes,\n            };\n\n            // Stockez les données dans le contexte\n            setStarsData(starsData);\n\n\n            const abbreviationToName = {};\n            abbrevs.split('\\n').filter(line => line.trim() !== '').forEach(line => {\n                const parts = line.split(',');\n                abbreviationToName[parts[0]] = {\n                    fullName: parts[1],\n                    description: parts[2]\n                };\n            });\n\n            // Traitement de constellationLinesText\n            const constellationLines = constellationLinesText.split('\\n').filter(line => !line.startsWith('#') && line.trim() !== '');\n            const parsedLines = constellationLines.map(line => {\n                const parts = line.split(',');\n                return {\n                    abbreviation: parts[0],\n                    group: parts[1],\n                    abbreviationGroup: parts[2],\n                    startStar: parseInt(parts[3]),\n                    endStar: parseInt(parts[4]),\n                    fullName: abbreviationToName[parts[0]] ? abbreviationToName[parts[0]].fullName : '',\n                    description: abbreviationToName[parts[0]] ? abbreviationToName[parts[0]].description : ''\n                };\n            });\n\n            setConstellationLines(parsedLines);\n            setIsLoaded(true);  // Mettre à jour isLoaded à true une fois que tout est chargé\n        });\n    }, []);\n\n    return (\n        <SkyContext.Provider value={{ isDebugEnabled, setIsDebugEnabled,isLoaded, shownConstellations, toggleShownConstellations, maxShownMagnitude, setMaxShownMagnitude, starsData, setStarsData, representation, setRepresentation, currentTime, location, toggleRepresentation, constellationLines, isLoaded, horizontalCoords, setHorizontalCoords }}>\n            {children}\n        </SkyContext.Provider>\n    );\n}\n\nexport { SkyContext, SkyProvider };\n","import { useThree, useFrame } from '@react-three/fiber';\nimport { useState, useEffect } from 'react';\nimport * as THREE from 'three';\nimport { Html } from '@react-three/drei';\nimport { SkyContext } from './contexts/Skycontext';\nimport { useContext } from 'react';\nimport { getIntersectionWithSphere } from './utils/astroUtils';\n/**\n * \n * @returns \n */\nfunction CameraControls() {\n  const [previousMousePosition, setPreviousMousePosition] = useState({ x: 0, y: 0 });\n  const [isMouseDown, setIsMouseDown] = useState(false);\n  const { isDebugEnabled,isLoaded } = useContext(SkyContext);\n  const { camera, gl, size } = useThree();\n\n  useEffect(() => {\n    function handleMouseMove(event) {\n      if (!isMouseDown) return;\n\n      const sensitivity = 0.005;\n\n      const deltaX = (event.offsetX - previousMousePosition.x) * sensitivity;\n      const deltaY = (event.offsetY - previousMousePosition.y) * sensitivity;\n\n      // Vérifier quelle rotation (horizontale ou verticale) est la plus grande\n      if (Math.abs(deltaX) > Math.abs(deltaY)) {\n        // Rotation horizontale seulement\n        console.log(\"Rotation horizontale\")\n        const horizontalRotation = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), deltaX);\n        camera.quaternion.multiply(horizontalRotation);\n      } else {\n        // Rotation verticale seulement\n        console.log(\"Rotation verticale\")\n        const verticalRotation = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), deltaY);\n        camera.quaternion.multiply(verticalRotation);\n      }\n\n      setPreviousMousePosition({ x: event.offsetX, y: event.offsetY });\n    }\n\n\n    const canvas = gl.domElement;\n    canvas.addEventListener('mousemove', handleMouseMove);\n\n    return () => {\n      canvas.removeEventListener('mousemove', handleMouseMove);\n    };\n  }, [gl.domElement, camera, previousMousePosition, isMouseDown]);\n\n  useEffect(() => {\n    function handleWheel(event) {\n      const zoomStep = 0.25;\n      const zoomChange = - Math.sign(event.deltaY) * zoomStep;\n  \n      const mouse = new THREE.Vector2(\n          (event.offsetX / gl.domElement.clientWidth) * 2 - 1,\n          -(event.offsetY / gl.domElement.clientHeight) * 2 + 1\n      );\n  \n      const raycaster = new THREE.Raycaster();\n      raycaster.setFromCamera(mouse, camera);\n  \n      const sphereCenter = new THREE.Vector3(0, 0, 0); \n      const sphereRadius = 1000;\n  \n      const intersectionPoint = getIntersectionWithSphere(camera.position, raycaster.ray.direction.normalize(), sphereCenter, sphereRadius);\n  \n      if (intersectionPoint) {\n          // Faites que la caméra regarde vers le point d'intersection\n          camera.lookAt(intersectionPoint);\n      }\n  \n      // Modifiez le zoom de la caméra comme auparavant\n      camera.zoom += zoomChange;\n      camera.zoom = THREE.MathUtils.clamp(camera.zoom, 1, 10);\n      camera.updateProjectionMatrix();\n  }\n  \n\n\n\n    const canvas = gl.domElement;\n    canvas.addEventListener('wheel', handleWheel);\n\n    return () => {\n      canvas.removeEventListener('wheel', handleWheel);\n    };\n  }, [gl.domElement, camera]);\n\n\n\n  useEffect(() => {\n\n    camera.layers.enable(0);  // permet à la caméra de voir la couche 0\n    camera.layers.enable(1);  // permet à la caméra de voir la couche 1\n\n    function handleKeyDown(event) {\n      const rotationAngle = 0.05;  // Ajustez cette valeur pour des rotations plus rapides ou plus lentes\n\n      switch (event.code) {\n        case 'ArrowUp':\n          camera.rotateOnAxis(new THREE.Vector3(1, 0, 0), rotationAngle);\n          break;\n        case 'ArrowDown':\n          camera.rotateOnAxis(new THREE.Vector3(1, 0, 0), -rotationAngle);\n          break;\n        case 'ArrowLeft':\n          camera.rotateOnAxis(new THREE.Vector3(0, 1, 0), rotationAngle);\n          break;\n        case 'ArrowRight':\n          camera.rotateOnAxis(new THREE.Vector3(0, 1, 0), -rotationAngle);\n          break;\n        default:\n          break;\n      }\n    }\n\n    window.addEventListener('keydown', handleKeyDown);\n\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [camera]);\n\n  useEffect(() => {\n    function handleMouseDown(event) {\n      if (event.button === 0) {\n        setIsMouseDown(true);\n        setPreviousMousePosition({ x: event.offsetX, y: event.offsetY });\n      }\n    }\n\n    function handleMouseUp() {\n      setIsMouseDown(false);\n    }\n\n    const canvas = gl.domElement;\n    canvas.addEventListener('mousedown', handleMouseDown);\n    canvas.addEventListener('mouseup', handleMouseUp);\n\n    return () => {\n      canvas.removeEventListener('mousedown', handleMouseDown);\n      canvas.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [gl.domElement]);\n\n  useEffect(() => {\n    camera.position.set(0, 0, 0);\n    camera.lookAt(new THREE.Vector3(1, 0, 0));\n    camera.updateProjectionMatrix();\n  }, []);\n\n  const viewDirection = new THREE.Vector3();\n  camera.getWorldDirection(viewDirection);\n\n  const distance = 0.5;  // ajustez cette valeur en fonction de la taille de votre scène\n  const offset = viewDirection.multiplyScalar(distance);\n\n  const htmlPosition = new THREE.Vector3().addVectors(camera.position, offset);\n\n\n  return (\n    <>\n      {isDebugEnabled && (\n        <Html position={htmlPosition.toArray()}>\n          <div style={{\n            position: 'absolute',\n            top: -200,\n            left: -200,\n            color: 'red',\n            display: 'flex',\n            flexDirection: 'row',\n            gap: '20px',\n            width: '600px'\n          }}>\n            <span>Zoom: {camera.zoom.toFixed(2)}</span>\n            <span>Position: {camera.position.x.toFixed(2)}, {camera.position.y.toFixed(2)}, {camera.position.z.toFixed(2)}</span>\n            <span>View Direction: {viewDirection.x.toFixed(2)}, {viewDirection.y.toFixed(2)}, {viewDirection.z.toFixed(2)}</span>\n          </div>\n        </Html>\n      )}\n    </>\n  );\n  \n}\n\nexport default CameraControls;\n","import { useEffect, useRef, useContext, useState } from 'react';\nimport { radToDeg } from 'three/src/math/MathUtils';\nimport { useThree } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { SkyContext } from '../contexts/Skycontext';\nimport { getIntersectionWithSphere } from '../utils/astroUtils';\n/**\n * \n */\nfunction Stars() {\n    const { scene, camera, gl } = useThree();\n    const { isDebugEnabled, setIsDebugEnabled,shownConstellations, representation, maxShownMagnitude, starsData } = useContext(SkyContext);   \n    const highlightedTextSpriteRef = useRef(null);\n    const starGroupRef = useRef(new THREE.Group());\n    const highlightedStarRef = useRef(null);\n    const raycaster = new THREE.Raycaster();\n    raycaster.layers.set(0);\n    raycaster.linePrecision = 100;\n    const mouse = new THREE.Vector2();\n    const rayHelperRef = useRef(null);\n\n\n\n\n    useEffect(() => {\n        console.log(\"Debug=\" + isDebugEnabled)\n    }, [isDebugEnabled]);\n\n    function addDebugRay() {\n        if (!rayHelperRef.current) {\n            console.log(\"Recréation du rayHelper\");\n            rayHelperRef.current = new THREE.ArrowHelper(raycaster.ray.direction, raycaster.ray.origin, 1050, 0xff0000);\n            scene.add(rayHelperRef.current);\n        }\n        else {\n            console.log(\"Mise à jour de la direction du RayHelper\");\n            rayHelperRef.current.setDirection(raycaster.ray.direction);\n            rayHelperRef.current.position.copy(raycaster.ray.origin);\n        }\n    }\n\n    function removeDebugRay() {\n        if (rayHelperRef.current) {\n            scene.remove(rayHelperRef.current);\n            rayHelperRef.current = null;\n        }\n    }\n    /**\n     * \n     * @param {*} text \n     * @returns \n     */\n    function createTextTexture(text) {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        ctx.font = '58px Arial'; // Modifiez selon vos préférences\n        ctx.fillStyle = \"blue\";\n        ctx.fillText(text.replace(\"_\", \" \"), 0, 58);\n        const texture = new THREE.CanvasTexture(canvas);\n        return texture;\n    }\n    /**\n     * \n     * @param {*} texture \n     * @returns \n     */\n    function createTextSprite(texture) {\n        const spriteMaterial = new THREE.SpriteMaterial({ map: texture, color: 0x0000ff });\n        const sprite = new THREE.Sprite(spriteMaterial);\n        sprite.scale.set(200, 100, 1); // Ajustez la taille selon vos préférences\n        return sprite;\n    }\n\n    useEffect(() => {\n        if (highlightedStarRef.current) {\n            console.log(\"Removing previously highlighted star.\");\n            starGroupRef.current.remove(highlightedStarRef.current);\n        }\n        if (highlightedTextSpriteRef.current) {\n            starGroupRef.current.remove(highlightedTextSpriteRef.current);\n        }\n    }, [shownConstellations]);\n    /**\n     * \n     * @param {*} star \n     */\n    function highlightStar(star) {\n        if (!star) {\n            console.log(\"Star is undefined\");\n            return;\n        }\n\n        if (!starsData || !starsData.altAzArray) {\n            console.log(\"starsData or starsData.altAzArray is undefined\");\n            return;\n        }\n\n        console.log(\"Highlight Star Function Called\");\n\n        if (highlightedStarRef.current) {\n            console.log(\"Removing previously highlighted star.\");\n            starGroupRef.current.remove(highlightedStarRef.current);\n        }\n\n        const circleGeometry = new THREE.RingGeometry(14, 24, 32);\n        const circleMaterial = new THREE.MeshBasicMaterial({ color: 0x0000FF, side: THREE.DoubleSide });\n        const circle = new THREE.Mesh(circleGeometry, circleMaterial);\n\n        // Get the star's (vertex) position from the Points geometry\n        const starPosition = star.object.geometry.attributes.position;\n        const vertex = new THREE.Vector3();\n        vertex.fromBufferAttribute(starPosition, star.index);\n        circle.position.copy(vertex);\n\n        console.log(\"Star Position:\", vertex);\n\n        // Calculate the direction from the camera to the star\n        const direction = new THREE.Vector3().subVectors(vertex, camera.position).normalize();\n\n        // Use the lookAt method to orient the circle towards the camera\n        circle.lookAt(camera.position);\n\n        starGroupRef.current.add(circle);\n        highlightedStarRef.current = circle;\n\n        // Récupérez le numéro Hipparcos de l'étoile\n        const hipNumber = starsData.hipparcosIds[star.index];\n        const starName = starsData.identStars[hipNumber];\n\n\n        const { azimuth, altitude } = starsData.altAzArray[star.index]\n        const { ra, dec } = starsData.raDec[star.index]\n\n        console.log(hipNumber + \" \" + starName + \" Ra=\" + radToDeg(ra) + \" Dec=\" + radToDeg(dec));\n        console.log(hipNumber + \" \" + starName + \" Azimut=\" + azimuth + \" Altitude=\" + altitude);\n        console.log(\"Magnitude=\" + starsData.magnitudes[star.index])\n        if (starName) {\n            const textTexture = createTextTexture(starName);\n            const textSprite = createTextSprite(textTexture);\n\n            // Positionnez le sprite à côté du cercle\n            textSprite.position.copy(vertex);\n            textSprite.position.x -= 70;\n            textSprite.position.y -= 70;\n            // Ajoutez le sprite au groupe d'étoiles\n            starGroupRef.current.add(textSprite);\n\n            // Si un sprite précédent a été mis en évidence, retirez-le\n            if (highlightedTextSpriteRef.current) {\n                starGroupRef.current.remove(highlightedTextSpriteRef.current);\n            }\n            highlightedTextSpriteRef.current = textSprite;\n        }\n        else console.log(\"Can't find starname of \" + hipNumber);\n        console.log(\"Star has been highlighted!\");\n    }\n\n\n    useEffect(() => {\n        if (!starsData) return;\n\n        // Vider le groupe d'étoiles\n        while (starGroupRef.current.children.length > 0) {\n            starGroupRef.current.remove(starGroupRef.current.children[0]);\n        }\n\n        // Supprimer l'étoile mise en évidence si elle existe\n        if (highlightedStarRef.current) {\n            starGroupRef.current.remove(highlightedStarRef.current);\n            highlightedStarRef.current = null;\n        }\n\n        const geometry = new THREE.BufferGeometry();\n        let positions; // Ce tableau contiendra les coordonnées des étoiles\n\n        if (representation === 'Horizontal' && starsData.horizontalCoords) {\n            positions = starsData.horizontalCoords;\n        } else {\n            positions = starsData.vertices;\n        }\n        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n        geometry.setAttribute('magnitude', new THREE.Float32BufferAttribute(starsData.magnitudes, 1));\n        geometry.setAttribute('hipparcosId', new THREE.Float32BufferAttribute(starsData.hipparcosIds, 1));\n\n        function createStarTexture() {\n            const canvas = document.createElement('canvas');\n            canvas.width = 64;\n            canvas.height = 64;\n            const ctx = canvas.getContext('2d');\n\n            const gradient = ctx.createRadialGradient(32, 32, 8, 32, 32, 32);\n            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');\n            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');\n\n            ctx.fillStyle = gradient;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n            const texture = new THREE.Texture(canvas);\n            texture.needsUpdate = true;\n            return texture;\n        }\n\n        const shaderMaterial = new THREE.ShaderMaterial({\n            uniforms: {\n                starTexture: { value: createStarTexture() },\n                maxMagnitude: { value: maxShownMagnitude }\n            },\n            vertexShader: `\n                attribute float magnitude;\n                uniform float maxMagnitude;\n                varying float vMagnitude;\n                void main() {\n                    vMagnitude = magnitude;\n                    gl_PointSize = 1.0 + 19.0 * (1.0 - vMagnitude / maxMagnitude);\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }\n            `,\n            fragmentShader: `\n                uniform sampler2D starTexture;\n                uniform float maxMagnitude;\n                varying float vMagnitude;\n                void main() {\n                    if (vMagnitude > maxMagnitude) {\n                        discard;\n                    }\n                    gl_FragColor = texture2D(starTexture, gl_PointCoord);\n                }\n            `,\n            transparent: true,\n            depthTest: true,\n            depthWrite: false,\n            blending: THREE.AdditiveBlending,\n        });\n\n        while (starGroupRef.current.children.length > 0) {\n            starGroupRef.current.remove(starGroupRef.current.children[0]);\n        }\n\n        const points = new THREE.Points(geometry, shaderMaterial);\n        starGroupRef.current.add(points);\n\n\n\n\n        scene.add(starGroupRef.current);\n\n        return () => {\n            scene.remove(starGroupRef.current);\n        };\n\n\n    }, [representation, starsData, scene, maxShownMagnitude]);\n\n\n    useEffect(() => {\n        function handleKeyDown(event) {\n            // Par exemple, vérifiez si la touche 'D' est pressée :\n            if (event.key === 'd' || event.key === 'D') {\n                setIsDebugEnabled(prev => !prev);  // bascule le mode debug\n            }\n        }\n        window.addEventListener('keydown', handleKeyDown);\n\n        return () => {\n            window.removeEventListener('keydown', handleKeyDown);\n        };\n    }, []);\n\n    useEffect(() => {\n        function onClick(event) {\n            console.log(\"Clic event \", event)\n            mouse.x = (event.offsetX / gl.domElement.clientWidth) * 2 - 1;\n            mouse.y = -(event.offsetY / gl.domElement.clientHeight) * 2 + 1;\n            raycaster.setFromCamera(mouse, camera);\n\n            let closestStarIndex = null;\n            let minDistance = Infinity;\n            const rayOrigin = new THREE.Vector3(0, 0, 0);    // Exemple d'origine  \n            const sphereCenter = new THREE.Vector3(0, 0, 0); // Exemple de centre\n            const sphereRadius = 1000;\n\n\n            const intersectionPoint = getIntersectionWithSphere(rayOrigin, raycaster.ray.direction.normalize(), sphereCenter, sphereRadius);\n            if (isDebugEnabled) addDebugRay();\n            else removeDebugRay();\n\n            if (intersectionPoint) {\n\n                console.log(`Intersection point: ${intersectionPoint.x}, ${intersectionPoint.y}, ${intersectionPoint.z}`);\n                let starPositions;\n                if (representation === 'Horizontal' && starsData.horizontalCoords) {\n                    starPositions = starsData.horizontalCoords;\n                } else {\n                    starPositions = starsData.vertices;\n                }\n                // Parcourir les étoiles visibles\n                for (let i = 0; i < starPositions.length / 3; i++) {\n                    if (starsData.magnitudes[i] <= maxShownMagnitude) {\n                        const starPosition = new THREE.Vector3(\n                            starPositions[i * 3],\n                            starPositions[i * 3 + 1],\n                            starPositions[i * 3 + 2]\n                        );\n                        const distance = starPosition.distanceTo(intersectionPoint);\n\n                        if (distance < minDistance) {\n                            minDistance = distance;\n                            closestStarIndex = i;\n                        }\n                    }\n                }\n\n                if (closestStarIndex !== null) {\n                    const hipparcosId = starsData.hipparcosIds[closestStarIndex];\n                    console.log(\"Etoile la plus proche Hipparcos ID:\", hipparcosId);\n\n                    // Mettez en surbrillance cette étoile\n                    const star = {\n                        object: {\n                            geometry: {\n                                attributes: {\n                                    position: new THREE.BufferAttribute(new Float32Array(starPositions), 3),\n                                    hipparcosId: new THREE.BufferAttribute(new Float32Array(starsData.hipparcosIds), 1)\n                                }\n                            }\n                        },\n                        index: closestStarIndex\n                    };\n                    highlightStar(star);\n                }\n\n            } else {\n                console.log(\"No intersection\");\n            }\n\n\n        }\n\n        window.addEventListener('click', onClick);\n\n        return () => {\n            window.removeEventListener('click', onClick);\n            removeDebugRay();\n        };\n    }, [representation, starsData, camera, gl, isDebugEnabled]);\n\n    return null;\n}\n\nexport default Stars;\n","import { useEffect, useRef, useContext } from 'react';\nimport { useThree } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { SkyContext } from '../contexts/Skycontext';\n\n/**\n * \n * @param {*} param0 \n * @returns \n */\nfunction Constellations() {\n    const { scene } = useThree();\n    const { representation, starsData, constellationLines } = useContext(SkyContext);\n\n    // Créez une référence pour le groupe\n    const constellationGroupRef = useRef(new THREE.Group());\n\n    function createTextTexture(text) {\n        const canvas = document.createElement('canvas');\n        const context = canvas.getContext('2d');\n        \n        context.font = '24px Arial';\n        const textWidth = context.measureText(text).width;\n        const textHeight = 24; // Approximation basée sur la taille de la fonte\n    \n        canvas.width = textWidth + 10; // Ajoutez une petite marge\n        canvas.height = textHeight + 10; // Ajoutez une petite marge\n    \n        // Remplissez le canvas avec une couleur transparente\n        context.fillStyle = 'rgba(0,0,0,0)';\n        context.fillRect(0, 0, canvas.width, canvas.height);\n    \n        // Configurations pour le texte\n        context.fillStyle = '#FFFFFF';\n        context.textAlign = 'center';\n        context.textBaseline = 'middle';\n        context.font = '24px Arial';\n        context.fillText(text, canvas.width / 2, canvas.height / 2);\n    \n        return new THREE.CanvasTexture(canvas);\n    }\n    \n\n\n\n    useEffect(() => {\n        if (!starsData || !constellationLines) return;\n\n        // Nettoyer le groupe avant de l'ajouter à nouveau\n        constellationGroupRef.current.children.forEach(child => {\n            console.log(\"Suppression de \", child);\n            constellationGroupRef.current.remove(child);\n        });\n        scene.remove(constellationGroupRef.current);\n        const material = new THREE.LineBasicMaterial({ color: 0xFFFFFF });\n\n        // Définir la variable positions en fonction de la représentation\n        const positions = representation === 'Horizontal' && starsData.horizontalCoords ? starsData.horizontalCoords : starsData.vertices;\n\n        const barycenters = {};\n\n        constellationLines.forEach(line => {\n            const startStarIndex = starsData.hipToIndex[line.startStar] * 3;\n            const endStarIndex = starsData.hipToIndex[line.endStar] * 3;\n\n            const startStarCoords = new THREE.Vector3(\n                positions[startStarIndex],\n                positions[startStarIndex + 1],\n                positions[startStarIndex + 2]\n            );\n\n            const endStarCoords = new THREE.Vector3(\n                positions[endStarIndex],\n                positions[endStarIndex + 1],\n                positions[endStarIndex + 2]\n            );\n\n            const geometry = new THREE.BufferGeometry().setFromPoints([startStarCoords, endStarCoords]);\n            const lineObj = new THREE.Line(geometry, material);\n            constellationGroupRef.current.add(lineObj);\n            // Calcul du barycentre\n            if (!barycenters[line.fullName]) {\n                barycenters[line.fullName] = {\n                    sum: new THREE.Vector3(0, 0, 0),\n                    count: 0\n                };\n            }\n\n            const barycenter = barycenters[line.fullName];\n            barycenter.sum.add(startStarCoords);\n            barycenter.sum.add(endStarCoords);\n            barycenter.count += 2;\n        });\n        // Création des labels pour chaque barycentre\n\n        for (const fullName in barycenters) {\n            const barycenter = barycenters[fullName];\n            const position = barycenter.sum.divideScalar(barycenter.count);\n\n            const textTexture = createTextTexture(fullName);\n            const spriteMaterial = new THREE.SpriteMaterial({ map: textTexture, transparent: true });\n            const sprite = new THREE.Sprite(spriteMaterial);\n            // Normalisez la position pour obtenir un vecteur directionnel.\n            const directionVector = position.clone().normalize();\n            // Multipliez le vecteur directionnel par une distance souhaitée.\n            const offset = directionVector.multiplyScalar(0.5); // Ajustez le scalaire selon la distance souhaitée\n            // Ajoutez ce déplacement à la position d'origine du sprite.\n            sprite.position.copy(position).add(offset);\n\n            sprite.scale.set(200, 100, 1); // Ajustez la taille selon vos besoins\n            constellationGroupRef.current.add(sprite);\n        }\n\n        scene.add(constellationGroupRef.current);\n\n        return () => {\n            // Supprimer tous les enfants du groupe\n            while (constellationGroupRef.current.children.length > 0) {\n                constellationGroupRef.current.remove(constellationGroupRef.current.children[0]);\n            } // Supprimer le groupe de la scène\n            scene.remove(constellationGroupRef.current);\n        };\n\n    }, [starsData, scene, constellationLines, representation]);\n\n\n    return null;\n}\n\nexport default Constellations;\n","import React, { useEffect, useContext } from 'react';\nimport Stars from './Stars';\nimport Constellations from './Constellations';\nimport * as THREE from 'three';\nimport { SkyContext } from '../contexts/Skycontext';\n/**\n * \n * @param {*} param0 \n * @returns \n */\nfunction Sky() {\n    const { shownConstellations, representation, location } = useContext(SkyContext);\n\n    useEffect(() => {\n        console.log(\"Changement de Representation\")\n    }, [representation, location]);\n\n    useEffect(() => {\n        console.log(\"Changement de Location\")\n    }, [location]);\n\n    return (\n        <>\n            {/* Affiche les constellations. */}\n            {shownConstellations === \"Oui\" && <Constellations />}\n            {/* Affiche les étoiles. */}\n            <Stars />\n        </>\n    );\n}\n\nexport default Sky;\n","import React, { useContext } from 'react';\nimport { Canvas } from '@react-three/fiber';\nimport Grid from './Grid';\nimport Horizon from './Horizon';\nimport CameraControls from '../CameraControls';\nimport Sky from './Sky';\nimport { SkyContext } from '../contexts/Skycontext';\n/*\nEn ce qui concerne les directions des axes dans Three.js:\n\nL'axe X est dirigé vers la droite.\nL'axe Y est dirigé vers le haut.\nL'axe Z est dirigé en avant, hors de l'écran.\nDonc, dans votre configuration:\n\nL'axe X (rouge dans axesHelper) pointe vers la droite.\nL'axe Y (vert dans axesHelper) pointe vers le haut.\nL'axe Z (bleu dans axesHelper) pointe directement hors de l'écran vers vous.\nLorsque vous utilisez axesHelper, il affiche des lignes représentant ces axes dans ces couleurs. Le rouge est pour X, le vert pour Y, et le bleu pour Z.\n*/\nfunction SkyDome() {\n    const { isLoaded } = useContext(SkyContext);\n    // Spinner CSS\n    const Spinner = () => (\n        <div style={{\n            display: 'flex',\n            justifyContent: 'center',\n            alignItems: 'center',\n            height: '100vh',\n            width: '100vw',\n        }}>\n            {/* Règles d'animation pour le spinner */}\n            <style>\n                {`\n                    @keyframes spin {\n                        0% { transform: rotate(0deg); }\n                        100% { transform: rotate(360deg); }\n                    }\n                `}\n            </style>\n            <div style={{\n                border: '16px solid #f3f3f3',\n                borderRadius: '50%',\n                borderTop: '16px solid #3498db',\n                width: '120px',\n                height: '120px',\n                animation: 'spin 2s linear infinite',\n            }}></div>\n        </div>\n    );\n\n\n    return (\n        !isLoaded ? <Spinner /> :\n            <Canvas style={{ background: '#001122' }} >\n                <orthographicCamera position={[0, 0, 0]} left={-1500} right={1500} top={1500} bottom={-1500} near={0.1} far={1500} />\n\n                {/* Afficher le ciel nocturne. */}\n                <Sky />\n\n                {/* Affiche l'horizon. */}\n                <Horizon />\n\n                {/* Affiche la grille. */}\n                <Grid />\n\n                {/* Affiche les aides pour les axes. */}\n                <axesHelper args={[1000]} />\n\n                {/* Éclaire la scène avec une lumière ambiante. */}\n                <ambientLight intensity={0.5} />\n\n                {/* Ajoute une lumière directionnelle pointant vers la position spécifiée. */}\n                <directionalLight position={[0, 0, 5]} intensity={1} />\n\n                {/* Contrôles pour la caméra. */}\n                <CameraControls />\n            </Canvas>\n    );\n}\n\nexport default SkyDome;\n","import React, { Component } from 'react';\n\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Mettez à jour l'état pour que le prochain rendu affiche le remplacement d'UI.\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // Vous pouvez également enregistrer l'erreur dans un service de reporting d'erreurs\n    console.error(\"Uncaught error:\", error, errorInfo);\n    this.setState({ error, errorInfo });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // Vous pouvez rendre n'importe quelle interface utilisateur de remplacement\n      return (\n        <div>\n          <h1>Quelque chose s'est mal passé.</h1>\n          <details style={{ whiteSpace: 'pre-wrap' }}>\n            {this.state.error && this.state.error.toString()}\n            <br />\n            {this.state.errorInfo.componentStack}\n          </details>\n        </div>\n      );\n    }\n\n    // Si il n'y a pas d'erreur, renvoyer les enfants normalement\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;\n","import React, { useContext, useState } from 'react';\nimport './Sidebar.css';\nimport { SkyContext } from '../contexts/Skycontext';\n\nfunction Sidebar() {\n    const { maxShownMagnitude, setMaxShownMagnitude, representation, toggleRepresentation, shownConstellations, toggleShownConstellations } = useContext(SkyContext);\n\n    // Utilisation d'un état local pour suivre la valeur du curseur\n    const [sliderValue, setSliderValue] = useState(maxShownMagnitude);\n\n    const handleSliderChange = (event) => {\n        const newMagnitude = parseFloat(event.target.value);\n        setSliderValue(newMagnitude);\n        setMaxShownMagnitude(newMagnitude);\n    };\n   \n    return (\n        <div className=\"sidebar\">\n            <h2 className=\"representation-title\">{representation}</h2>\n            <button onClick={toggleRepresentation}>Basculer la représentation</button>\n            <h2 className=\"constellations-title\">Constellations: {shownConstellations}</h2>\n            <div\n                className={`toggle-btn ${shownConstellations === 'Oui' ? 'on' : 'off'}`}\n                onClick={toggleShownConstellations}\n            >\n                <div className=\"toggle-indicator\"></div>\n            </div>\n\n            <div className=\"magnitude-slider\">\n                <label>Magnitude maximale affichée: {sliderValue}</label>\n                <input\n                    type=\"range\"\n                    min=\"0\"\n                    max=\"10\"\n                    step=\"0.1\"\n                    value={sliderValue}\n                    onChange={handleSliderChange}\n                />\n            </div>\n            <p className=\"debug-info\">Appuyez sur <strong>d</strong> pour passer en mode debug.</p>\n        </div>\n    );\n}\n\nexport default Sidebar;\n","// Header.js\nimport React, { useContext } from 'react';\nimport './Header.css';\nimport { SkyContext } from '../contexts/Skycontext';\n\nfunction Header({deviceType}) {\n    const { currentTime, location } = useContext(SkyContext);\n    //console.log(\"Location: \", location)\n\n    const offsetMinutes = currentTime.getTimezoneOffset();\n    const offsetHours = offsetMinutes / 60;\n\n    return (\n        <div className=\"header\">\n          {deviceType !== \"mobile\" && <h1 className=\"header-title\">SkySphereJS</h1>}\n            <div className=\"right-section\">\n                <span className=\"location\">\n                    {location.latitude && location.longitude && location.cityName?\n                        `Lat: ${location.latitude.toFixed(2)}, Long: ${location.longitude.toFixed(2)}, ${location.cityName}` :\n                        \"Localisation non disponible\"}\n                </span>\n                <span className=\"time\"> {currentTime.toLocaleTimeString()} UTC {offsetHours >= 0 ? '+' : ''}{offsetHours}</span>\n\n            </div>\n        </div>\n    );\n}\n\nexport default Header;\n","import React, { useState, useEffect } from 'react';\nimport './App.css';\nimport SkyDome from './components/SkyDome';\nimport ErrorBoundary from './ErrorBoundary';\nimport Sidebar from './components/Sidebar';\nimport Header from './components/Header';\nimport { SkyProvider } from './contexts/Skycontext';\n\nfunction App() {\n  const [deviceType, setDeviceType] = useState(getDeviceType(window.innerWidth));\n/**\n  * \n  * @param {*} width \n  * @returns \n  */\nfunction getDeviceType(width) {\n  console.log(\"Width=\"+width);\n  if (width < 768) {\n    return 'mobile';\n  } else if (width <= 1180) {\n    return 'tablette';\n  } else {\n    return 'ordinateur';\n  }\n}\nuseEffect(() => {\n  const handleResize = () => {\n    setDeviceType(getDeviceType(window.innerWidth));\n  };\n\n  window.addEventListener('resize', handleResize);\n  return () => {\n    window.removeEventListener('resize', handleResize);\n  };\n}, []);\n\n\n  return (\n    <div className={`App ${deviceType === \"mobile\" ? \"mobile\" : \"\"}`}>\n      <SkyProvider>\n        <ErrorBoundary>\n          <Header deviceType={deviceType} />\n          <div className=\"content\">\n            <SkyDome />\n          </div>\n          {deviceType !== \"mobile\" && <Sidebar />}\n        </ErrorBoundary>\n      </SkyProvider>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n\n\n"],"sourceRoot":""}