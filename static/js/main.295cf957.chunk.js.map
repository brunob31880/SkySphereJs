{"version":3,"sources":["components/RADECGrid.js","components/Horizon.js","utils/unitUtils.js","contexts/Skycontext.js","CameraControls.js","components/Stars.js","components/Constellations.js","components/Sky.js","utils/astroUtils.js","components/SkyDome.js","ErrorBoundary.js","components/Sidebar.js","components/Header.js","App.js","index.js"],"names":["RADECGrid","group","useRef","useEffect","dashMaterialRA","THREE","color","dashSize","gapSize","dashMaterialDEC","createCircleGeometry","radius","geometry","positions","Float32Array","i","theta","Math","PI","cos","sin","setAttribute","load","font","ra","circGeom","rotateZ","degToRad","rotateY","circ","computeLineDistances","layers","set","current","add","textGeom","String","size","height","curveSegments","bevelEnabled","textMaterial","textMesh","position","x","z","y","lookAt","dec","translateY","_jsx","ref","Horizon","meshRef","renderOrder","_jsxs","rotation","children","attach","args","side","transparent","opacity","depthWrite","degrees","hmsToRad","hours","minutes","seconds","hmsToDeg","dmsToRad","dmsToDeg","SkyContext","React","createContext","SkyProvider","_ref","_useState","useState","_useState2","_slicedToArray","representation","setRepresentation","_useState3","_useState4","shownConstellations","setShownConstellations","_useState5","Date","_useState6","currentTime","setCurrentTime","_useState7","latitude","longitude","_useState8","location","setLocation","_useState9","_useState10","starsData","setStarsData","_useState11","_useState12","hipToIndex","_useState13","_useState14","maxShownMagnitude","setMaxShownMagnitude","_useState15","_useState16","constellationLines","setConstellationLines","_useState17","_useState18","isLoaded","setIsLoaded","R","navigator","geolocation","getCurrentPosition","coords","error","console","interval","setInterval","clearInterval","Promise","all","fetch","concat","process","then","response","text","_ref2","_ref3","starsDataText","constellationLinesText","idents","minRA","Infinity","maxRA","minDEC","maxDEC","lines","split","filter","line","startsWith","trim","hipparcosIds","newMagnitudes","presentHips","map","parseInt","sort","a","b","missingHips","Array","from","length","_","hip","includes","log","forEach","index","parts","hipNumber","raParts","part","parseFloat","decParts","apply","_toConsumableArray","mag","isNaN","push","Error","validMagnitudes","minMagnitude","min","maxMagnitude","max","identStars","starName","substring","endsWith","vertices","magnitudes","parsedLines","abbreviation","abbreviationGroup","startStar","endStar","Provider","value","_defineProperty","toggleShownConstellations","toggleRepresentation","CameraControls","previousMousePosition","setPreviousMousePosition","isMouseDown","setIsMouseDown","_useThree","useContext","useThree","camera","gl","handleMouseMove","event","deltaX","offsetX","deltaY","offsetY","abs","horizontalRotation","setFromAxisAngle","quaternion","multiply","verticalRotation","canvas","domElement","addEventListener","removeEventListener","handleWheel","zoomChange","sign","zoom","clamp","updateProjectionMatrix","handleKeyDown","rotationAngle","code","rotateOnAxis","enable","window","handleMouseDown","button","handleMouseUp","_Fragment","Html","style","top","left","display","flexDirection","gap","width","toFixed","getWorldDirection","Stars","scene","_useContext","isDebugEnabled","setIsDebugEnabled","highlightedTextSpriteRef","starGroupRef","highlightedStarRef","raycaster","linePrecision","mouse","rayHelperRef","removeDebugRay","remove","highlightStar","star","circleGeometry","circleMaterial","circle","starPosition","object","attributes","vertex","fromBufferAttribute","copy","subVectors","normalize","textSprite","texture","spriteMaterial","sprite","scale","createTextSprite","document","createElement","ctx","getContext","fillStyle","fillText","createTextTexture","shaderMaterial","uniforms","starTexture","gradient","createRadialGradient","addColorStop","fillRect","needsUpdate","createStarTexture","vertexShader","fragmentShader","depthTest","blending","points","visibleStarPositions","hitboxMaterial","hitboxGeometry","hitboxes","key","prev","onClick","clientWidth","clientHeight","setFromCamera","closestStarIndex","minDistance","rayOrigin","sphereCenter","rotationMatrixX","makeRotationX","rotationMatrixY","makeRotationY","combinedRotationMatrix","multiplyMatrices","inverseRotationMatrix","getInverse","intersectionPoint","rayDirection","sphereRadius","oc","dot","discriminant","t1","sqrt","t2","t","getIntersectionWithSphere","ray","direction","clone","applyMatrix4","distance","distanceTo","hipparcosId","Constellations","constellationGroupRef","material","startStarIndex","endStarIndex","undefined","startStarCoords","endStarCoords","setFromPoints","Sky","setRotation","LST","GST","UTC","getSiderealTime","LSTinRadians","inclination","SkyDome","Canvas","background","right","bottom","near","far","intensity","ErrorBoundary","_Component","_inherits","_super","_createSuper","props","_this","_classCallCheck","call","state","hasError","errorInfo","_createClass","this","setState","whiteSpace","toString","componentStack","Component","Sidebar","sliderValue","setSliderValue","className","type","step","onChange","newMagnitude","target","Header","deviceType","offsetHours","getTimezoneOffset","toLocaleTimeString","App","getDeviceType","innerWidth","setDeviceType","handleResize","ReactDOM","createRoot","getElementById","render","StrictMode"],"mappings":"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","file":"static/js/main.295cf957.chunk.js","sourcesContent":["import React, { useRef, useEffect } from 'react';\nimport * as THREE from 'three';\n\nfunction RADECGrid() {\n    const group = useRef();\n\n    useEffect(() => {\n        const segments = 64;\n        const numDivisions = 36;  // Par exemple, pour 36 divisions\n        const increment = 360 / numDivisions;\n\n        const dashMaterialRA = new THREE.LineDashedMaterial({\n            color: 0x00ff00,\n            dashSize: 10,\n            gapSize: 5\n        });\n\n        const dashMaterialDEC = new THREE.LineDashedMaterial({\n            color: 0x0000ff,\n            dashSize: 10,\n            gapSize: 5\n        });\n\n        const createCircleGeometry = (radius) => {\n            const geometry = new THREE.BufferGeometry();\n            const positions = new Float32Array((segments + 1) * 3);\n\n            for (let i = 0; i <= segments; i++) {\n                const theta = (i / segments) * Math.PI * 2;\n                positions[i * 3] = radius * Math.cos(theta);\n                positions[i * 3 + 1] = 0;\n                positions[i * 3 + 2] = radius * Math.sin(theta);\n            }\n\n            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n            return geometry;\n        };\n        // Étape 1: Chargez une police\n        const fontLoader = new THREE.FontLoader();\n\n        fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {\n            for (let ra = 0; ra < 360; ra += increment) {\n                const circGeom = createCircleGeometry(1000);\n\n                // Tourner le cercle de 90 degrés autour de l'axe Z pour le positionner dans le plan YZ.\n                circGeom.rotateZ(THREE.MathUtils.degToRad(90));\n\n                // Ensuite, tourner la géométrie autour de l'axe Y par ra degrés.\n                circGeom.rotateY(THREE.MathUtils.degToRad(ra));\n\n                const circ = new THREE.Line(circGeom, dashMaterialRA);\n                circ.computeLineDistances();\n                // Pour le raycasting\n                circ.layers.set(1);\n                group.current.add(circ);\n                // Étape 2: Créez une TextGeometry pour chaque valeur de 'ra'\n                const textGeom = new THREE.TextGeometry(String(ra), {\n                    font: font,\n                    size: 40,  // Ajustez selon vos besoins\n                    height: 5, // Ajustez selon vos besoins\n                    curveSegments: 12,\n                    bevelEnabled: false,\n                });\n\n                // Étape 3: Positionnez le texte sur la sphère\n                const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });  // Couleur du texte, ajustez selon vos besoins\n                const textMesh = new THREE.Mesh(textGeom, textMaterial);\n\n                const radius = 1000;\n                textMesh.position.x = radius * Math.cos(THREE.MathUtils.degToRad(ra));\n                textMesh.position.z = radius * Math.sin(THREE.MathUtils.degToRad(ra));\n                textMesh.position.y = 0;\n\n                textMesh.lookAt(0, 0, 0);  // Faites en sorte que le texte regarde vers le centre de la sphère\n                group.current.add(textMesh);\n            }\n\n\n            for (let dec = -90; dec < 90; dec += increment) {\n                const circGeom = createCircleGeometry(1000 * Math.cos(THREE.MathUtils.degToRad(dec)));\n                const circ = new THREE.Line(circGeom, dashMaterialDEC);\n                circ.translateY(1000 * Math.sin(THREE.MathUtils.degToRad(dec)));\n                circ.computeLineDistances();\n                // Pour le raycasting\n                circ.layers.set(1);\n                group.current.add(circ);\n                // Étape 2: Créez une TextGeometry pour chaque valeur de 'dec'\n                const textGeom = new THREE.TextGeometry(String(dec), {\n                    font: font,\n                    size: 40,  // Taille du texte, ajustez selon vos besoins\n                    height: 5, // Profondeur du texte, ajustez selon vos besoins\n                    curveSegments: 12,\n                    bevelEnabled: false,\n                });\n\n                // Étape 3: Positionnez le texte sur la sphère\n                const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });  // Couleur du texte, ajustez selon vos besoins\n                const textMesh = new THREE.Mesh(textGeom, textMaterial);\n\n                const radius = 1000;\n                textMesh.position.x = radius *  Math.cos(THREE.MathUtils.degToRad(dec));\n                textMesh.position.y = radius * Math.sin(THREE.MathUtils.degToRad(dec));\n                textMesh.position.z = 0\n\n                textMesh.lookAt(0, 0, 0);  // Faites en sorte que le texte regarde vers le centre de la sphère\n                group.current.add(textMesh);\n            }\n\n        })\n    }, []);\n\n    return <group ref={group} />;\n}\n\nexport default RADECGrid;\n","import React,{useRef,useEffect} from 'react';\nimport * as THREE from 'three';\n\nfunction Horizon() {\n    const meshRef = useRef();\n\n    useEffect(() => {\n        if (meshRef.current) {\n            meshRef.current.renderOrder = 1; // Assurez-vous que c'est un numéro plus élevé que les autres objets de votre scène\n        }\n    }, []);\n    const radius=1000;\n    const segments =64;\n    return (\n        <mesh ref={meshRef} rotation={[-Math.PI / 2, 0, 0]}>\n            <ringBufferGeometry attach=\"geometry\" args={[0, radius, segments]} />\n            <meshBasicMaterial \n                attach=\"material\" \n                color={0xffffff} \n                side={THREE.DoubleSide} \n                transparent={true} \n                opacity={0.1}\n                depthWrite={false} // Ajout de cette ligne\n            />\n        </mesh>\n    );\n}\n\nexport default Horizon;\n","const degToRad = (degrees) => {\n    return degrees * (Math.PI / 180);\n}\n\nconst hmsToDeg = (hours, minutes, seconds) => {\n    return 15 * (hours + minutes / 60 + seconds / 3600);\n}\n\nconst dmsToDeg = (degrees, minutes, seconds) => {\n    return degrees + minutes / 60 + seconds / 3600;\n}\n\nconst hmsToRad = (hours, minutes, seconds) => {\n    return degToRad(hmsToDeg(hours, minutes, seconds));\n}\n\nconst dmsToRad = (degrees, minutes, seconds) => {\n    return degToRad(dmsToDeg(degrees, minutes, seconds));\n}\n\nexport { degToRad, hmsToDeg, dmsToDeg, hmsToRad, dmsToRad };\n","// SkyContext.js\nimport React, { useState, useEffect } from 'react';\nimport { hmsToRad, dmsToRad } from '../utils/unitUtils';\n\nconst SkyContext = React.createContext();\n\nfunction SkyProvider({ children }) {\n    const [representation, setRepresentation] = useState(\"Equatorial\");\n    const [shownConstellations, setShownConstellations] = useState(\"Oui\");\n    const [currentTime, setCurrentTime] = useState(new Date());\n    const [location, setLocation] = useState({ latitude: null, longitude: null });\n    const [starsData, setStarsData] = useState(null);\n    const [hipToIndex, setHipToIndex] = useState({});\n    const [maxShownMagnitude, setMaxShownMagnitude] = useState(6);\n    const [constellationLines, setConstellationLines] = useState([]);\n    const [isLoaded, setIsLoaded] = useState(false);\n    const R = 1000; // Rayon de la sphère céleste\n\n    const toggleRepresentation = () => {\n        if (representation === 'Equatorial') {\n            setRepresentation('Horizontal');\n        } else {\n            setRepresentation('Equatorial');\n        }\n    };\n\n    const toggleShownConstellations = () => {\n        if (shownConstellations === \"Oui\") {\n            setShownConstellations(\"Non\");\n        } else {\n            setShownConstellations(\"Oui\");\n        }\n    };\n\n    useEffect(() => {\n        if (navigator.geolocation) {\n            navigator.geolocation.getCurrentPosition(position => {\n                setLocation({\n                    latitude: position.coords.latitude,\n                    longitude: position.coords.longitude\n                });\n            }, error => {\n                console.error(\"Erreur de géolocalisation:\", error);\n            });\n        } else {\n            console.error(\"Géolocalisation non supportée par ce navigateur.\");\n        }\n    }, []);\n\n    useEffect(() => {\n        const interval = setInterval(() => {\n            setCurrentTime(new Date());\n        }, 1000);\n\n        return () => clearInterval(interval);\n    }, []);\n    const parseDMS = (dms) => {\n        const parts = dms.split(/\\s+/);\n        return parts.map(part => parseFloat(part));\n    };\n\n    const parseHMS = (hms) => {\n        const parts = hms.split(/\\s+/);\n        return parts.map(part => parseFloat(part));\n    };\n    useEffect(() => {\n        Promise.all([\n            fetch(`${process.env.PUBLIC_URL}/datas/hip.tsv`).then(response => response.text()),\n            fetch(`${process.env.PUBLIC_URL}/datas/constellation_line_hip.csv`).then(response => response.text()),\n            fetch(`${process.env.PUBLIC_URL}/datas/ident4.csv`).then(response => response.text())\n        ]).then(([starsDataText, constellationLinesText, idents]) => {\n            // Logique pour traiter starsDataText et constellationLinesText\n            // Traitement de starsDataText\n            let minRA = Infinity;\n            let maxRA = -Infinity;\n            let minDEC = Infinity;\n            let maxDEC = -Infinity;\n\n            const lines = starsDataText.split('\\n').filter(line => !line.startsWith('#') && line.trim() !== '');\n\n            const coords = [];\n            const hipparcosIds = [];\n            const newMagnitudes = [];\n            const RA_INDEX = 1;\n            const DEC_INDEX = 2;\n            const MAG_INDEX = 3;\n\n\n            // Créez une liste de tous les numéros HIP présents dans le fichier\n            const presentHips = lines.map(line => parseInt(line.split('|')[0])).sort((a, b) => a - b);\n\n            // Créez une liste complète de 1 à 118322\n            const allHips = Array.from({ length: 118322 }, (_, i) => i + 1);\n\n            // Trouvez les numéros HIP manquants\n            const missingHips = allHips.filter(hip => !presentHips.includes(hip));\n\n            console.log(\"Missing HIP numbers:\", missingHips);\n\n            lines.forEach((line, index) => {\n                const parts = line.split('|');\n                const hipNumber = parseInt(parts[0], 10);\n                hipToIndex[hipNumber] = index;\n                const raParts = parseHMS(parts[RA_INDEX]);\n                const decParts = parseDMS(parts[DEC_INDEX]);\n\n                const ra = hmsToRad(...raParts);\n                const dec = dmsToRad(...decParts);\n                const mag = parseFloat(parts[MAG_INDEX]);\n\n                if (ra < minRA) minRA = ra;\n                if (ra > maxRA) maxRA = ra;\n                if (dec < minDEC) minDEC = dec;\n                if (dec > maxDEC) maxDEC = dec;\n\n                if (!isNaN(mag)) {\n                    newMagnitudes.push(mag);\n                } else {\n                    console.error(\"Invalid magnitude value:\", parts[MAG_INDEX]);\n                }\n\n                const x = R * Math.cos(dec) * Math.cos(ra);\n                const z = R * Math.cos(dec) * Math.sin(ra);\n                const y = R * Math.sin(dec);\n                // pour deboggage affichage de la position de la polaire\n\n                if (hipNumber === 11767) console.log('Etoile polaire: X=' + x + \" Y=\" + y + \" Z=\" + z + \" \");\n                if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {\n                    coords.push(x, y, z);\n                    hipparcosIds.push(hipNumber)\n                } else {\n                    console.error(\"Problem with HIP=\" + parts[0]);\n                }\n\n                // Vérifier la taille des tableaux de données\n                if ((coords.length / 3) !== newMagnitudes.length) {\n                    console.error(\"Mismatch detected at line index:\", index);\n                    console.error(\"Line content:\", line);\n                    throw new Error(\"Mismatch in data arrays\"); // This will stop further processing\n                }\n            });\n\n\n            console.log(\"Nb étoiles:\" + newMagnitudes.length);\n            console.log(\"RA Range:\", minRA, \"-\", maxRA);\n            console.log(\"DEC Range:\", minDEC, \"-\", maxDEC);\n\n            // Vérifier la gamme de magnitudes\n            const validMagnitudes = newMagnitudes.filter(mag => !isNaN(mag));\n\n            const minMagnitude = Math.min(...validMagnitudes);\n            const maxMagnitude = Math.max(...validMagnitudes);\n            console.log(\"Magnitude Range:\", minMagnitude, \"-\", maxMagnitude);\n\n            const identStars = {};\n\n            // console.log(idents.split('\\n'))\n            const identLines = idents.split('\\n').filter(line => line.trim() !== '');\n            identLines.forEach(line => {\n                const parts = line.split('|');\n                let starName = parts[0].trim();\n                // Retire les guillemets en trop\n                if (starName.startsWith('\"')) {\n                    starName = starName.substring(1);\n                }\n                if (starName.endsWith('\"')) {\n                    starName = starName.substring(0, starName.length - 1);\n                }\n\n                const hipNumber = parseInt(parts[1].trim(), 10);\n\n                if (!isNaN(hipNumber)) {\n                    identStars[hipNumber] = starName;\n                }\n            });\n\n\n            const starsData = {\n                vertices: coords,\n                magnitudes: newMagnitudes,\n                hipToIndex: hipToIndex,\n                hipparcosIds,\n                identStars\n            };\n            // Stockez les données dans le contexte\n            setStarsData(starsData);\n            // Traitement de constellationLinesText\n            const constellationLines = constellationLinesText.split('\\n').filter(line => !line.startsWith('#') && line.trim() !== '');\n            const parsedLines = constellationLines.map(line => {\n                const parts = line.split(',');\n                return {\n                    abbreviation: parts[0],\n                    group: parts[1],\n                    abbreviationGroup: parts[2],\n                    startStar: parseInt(parts[3]),\n                    endStar: parseInt(parts[4])\n                };\n            });\n\n            setConstellationLines(parsedLines);\n            setIsLoaded(true);  // Mettre à jour isLoaded à true une fois que tout est chargé\n        });\n    }, []);\n\n    return (\n        <SkyContext.Provider value={{ isLoaded, shownConstellations, toggleShownConstellations, maxShownMagnitude, setMaxShownMagnitude, starsData, setStarsData, representation, setRepresentation, currentTime, location, toggleRepresentation, constellationLines, isLoaded }}>\n            {children}\n        </SkyContext.Provider>\n    );\n}\n\nexport { SkyContext, SkyProvider };\n","import { useThree, useFrame } from '@react-three/fiber';\nimport { useState, useEffect } from 'react';\nimport * as THREE from 'three';\nimport { Html } from '@react-three/drei';\nimport { SkyContext } from './contexts/Skycontext';\nimport { useContext } from 'react';\n\nfunction CameraControls() {\n  const [previousMousePosition, setPreviousMousePosition] = useState({ x: 0, y: 0 });\n  const [isMouseDown, setIsMouseDown] = useState(false);\n  const { isLoaded } = useContext(SkyContext);\n  const { camera, gl, size } = useThree();\n\n  useEffect(() => {\n    function handleMouseMove(event) {\n      if (!isMouseDown) return;\n\n      const sensitivity = 0.005;\n\n      const deltaX = (event.offsetX - previousMousePosition.x) * sensitivity;\n      const deltaY = (event.offsetY - previousMousePosition.y) * sensitivity;\n\n      // Vérifier quelle rotation (horizontale ou verticale) est la plus grande\n      if (Math.abs(deltaX) > Math.abs(deltaY)) {\n        // Rotation horizontale seulement\n        console.log(\"Rotation horizontale\")\n        const horizontalRotation = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), deltaX);\n        camera.quaternion.multiply(horizontalRotation);\n      } else {\n        // Rotation verticale seulement\n        console.log(\"Rotation verticale\")\n        const verticalRotation = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), deltaY);\n        camera.quaternion.multiply(verticalRotation);\n      }\n\n      setPreviousMousePosition({ x: event.offsetX, y: event.offsetY });\n    }\n\n\n    const canvas = gl.domElement;\n    canvas.addEventListener('mousemove', handleMouseMove);\n\n    return () => {\n      canvas.removeEventListener('mousemove', handleMouseMove);\n    };\n  }, [gl.domElement, camera, previousMousePosition, isMouseDown]);\n\n  useEffect(() => {\n    function handleWheel(event) {\n      const zoomStep = 0.25;\n      const zoomChange = - Math.sign(event.deltaY) * zoomStep;\n      camera.zoom += zoomChange;\n      camera.zoom = THREE.MathUtils.clamp(camera.zoom, 1, 10);\n      camera.updateProjectionMatrix();\n    }\n\n    const canvas = gl.domElement;\n    canvas.addEventListener('wheel', handleWheel);\n\n    return () => {\n      canvas.removeEventListener('wheel', handleWheel);\n    };\n  }, [gl.domElement, camera]);\n\n\n\n  useEffect(() => {\n\n    camera.layers.enable(0);  // permet à la caméra de voir la couche 0\n    camera.layers.enable(1);  // permet à la caméra de voir la couche 1\n\n    function handleKeyDown(event) {\n      const rotationAngle = 0.05;  // Ajustez cette valeur pour des rotations plus rapides ou plus lentes\n\n      switch (event.code) {\n        case 'ArrowUp':\n          camera.rotateOnAxis(new THREE.Vector3(1, 0, 0), rotationAngle);\n          break;\n        case 'ArrowDown':\n          camera.rotateOnAxis(new THREE.Vector3(1, 0, 0), -rotationAngle);\n          break;\n        case 'ArrowLeft':\n          camera.rotateOnAxis(new THREE.Vector3(0, 1, 0), rotationAngle);\n          break;\n        case 'ArrowRight':\n          camera.rotateOnAxis(new THREE.Vector3(0, 1, 0), -rotationAngle);\n          break;\n        default:\n          break;\n      }\n    }\n\n    window.addEventListener('keydown', handleKeyDown);\n\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [camera]);\n\n  useEffect(() => {\n    function handleMouseDown(event) {\n      if (event.button === 0) {\n        setIsMouseDown(true);\n        setPreviousMousePosition({ x: event.offsetX, y: event.offsetY });\n      }\n    }\n\n    function handleMouseUp() {\n      setIsMouseDown(false);\n    }\n\n    const canvas = gl.domElement;\n    canvas.addEventListener('mousedown', handleMouseDown);\n    canvas.addEventListener('mouseup', handleMouseUp);\n\n    return () => {\n      canvas.removeEventListener('mousedown', handleMouseDown);\n      canvas.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [gl.domElement]);\n\n  useEffect(() => {\n    camera.position.set(0, 0, 0);\n    camera.lookAt(new THREE.Vector3(1, 0, 0));\n    camera.updateProjectionMatrix();\n  }, []);\n\n  return (\n    <>\n      <Html>\n        <div style={{\n          position: 'absolute',\n          top: -200,\n          left: -200,\n          color: 'white',\n          display: 'flex',\n          flexDirection: 'row',\n          gap: '20px',\n          width: '600px'\n        }}>\n          <span>Zoom: {camera.zoom.toFixed(2)}</span>\n          <span>Position: {camera.position.x.toFixed(2)}, {camera.position.y.toFixed(2)}, {camera.position.z.toFixed(2)}</span>\n          <span>LookAt: {camera.getWorldDirection(new THREE.Vector3()).x.toFixed(2)}, {camera.getWorldDirection(new THREE.Vector3()).y.toFixed(2)}, {camera.getWorldDirection(new THREE.Vector3()).z.toFixed(2)}</span>\n        </div>\n      </Html>\n    </>\n  );\n}\n\nexport default CameraControls;\n","import { useEffect, useRef, useContext, useState } from 'react';\n\nimport { useThree } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { SkyContext } from '../contexts/Skycontext';\n/**\n * \n */\nfunction Stars({ rotation }) {\n    const { scene, camera, gl } = useThree();\n    const { maxShownMagnitude, starsData } = useContext(SkyContext);\n\n    const [isDebugEnabled, setIsDebugEnabled] = useState(true);\n    const hitboxes = useRef([]);\n    const highlightedTextSpriteRef = useRef(null);\n\n    const starGroupRef = useRef(new THREE.Group());\n    const highlightedStarRef = useRef(null);\n    const raycaster = new THREE.Raycaster();\n    raycaster.layers.set(0);\n    raycaster.linePrecision = 100;\n    const mouse = new THREE.Vector2();\n    const rayHelperRef = useRef(null);\n    // detection par lancement de rayon \n    const rayCasting = false\n\n    useEffect(() => {\n        starGroupRef.current.rotation.y = rotation.y;\n        starGroupRef.current.rotation.x = rotation.x;\n    }, [rotation]);\n\n    useEffect(() => {\n        console.log(\"Debug=\" + isDebugEnabled)\n    }, [isDebugEnabled]);\n\n    function addDebugRay() {\n        if (!rayHelperRef.current) {\n            console.log(\"Recréation du rayHelper\");\n            rayHelperRef.current = new THREE.ArrowHelper(raycaster.ray.direction, raycaster.ray.origin, 1050, 0xff0000);\n            scene.add(rayHelperRef.current);\n        }\n        else {\n            console.log(\"Mise à jour de la direction du RayHelper\");\n            rayHelperRef.current.setDirection(raycaster.ray.direction);\n            rayHelperRef.current.position.copy(raycaster.ray.origin);\n        }\n    }\n\n\n    function removeDebugRay() {\n        if (rayHelperRef.current) {\n            scene.remove(rayHelperRef.current);\n            rayHelperRef.current = null;\n        }\n    }\n    /**\n     * \n     * @param {*} text \n     * @returns \n     */\n    function createTextTexture(text) {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n\n        ctx.font = '58px Arial'; // Modifiez selon vos préférences\n        ctx.fillStyle = \"blue\";\n        ctx.fillText(text, 0, 58);\n        const texture = new THREE.CanvasTexture(canvas);\n        return texture;\n    }\n    /**\n     * \n     * @param {*} texture \n     * @returns \n     */\n    function createTextSprite(texture) {\n        const spriteMaterial = new THREE.SpriteMaterial({ map: texture, color: 0x0000ff });\n        const sprite = new THREE.Sprite(spriteMaterial);\n        sprite.scale.set(200, 100, 1); // Ajustez la taille selon vos préférences\n        return sprite;\n    }\n\n    /**\n     * \n     * @param {*} star \n     */\n    function highlightStar(star) {\n        console.log(\"Highlight Star Function Called\");\n\n        if (highlightedStarRef.current) {\n            console.log(\"Removing previously highlighted star.\");\n            starGroupRef.current.remove(highlightedStarRef.current);\n        }\n\n        const circleGeometry = new THREE.RingGeometry(14, 24, 32);\n        const circleMaterial = new THREE.MeshBasicMaterial({ color: 0x0000FF, side: THREE.DoubleSide });\n        const circle = new THREE.Mesh(circleGeometry, circleMaterial);\n\n        // Get the star's (vertex) position from the Points geometry\n        const starPosition = star.object.geometry.attributes.position;\n        const vertex = new THREE.Vector3();\n        vertex.fromBufferAttribute(starPosition, star.index);\n        circle.position.copy(vertex);\n\n        console.log(\"Star Position:\", vertex);\n\n        // Calculate the direction from the camera to the star\n        const direction = new THREE.Vector3().subVectors(vertex, camera.position).normalize();\n\n        // Use the lookAt method to orient the circle towards the camera\n        circle.lookAt(camera.position);\n\n        starGroupRef.current.add(circle);\n        highlightedStarRef.current = circle;\n        // Récupérez le numéro Hipparcos de l'étoile\n        const hipNumber = starsData.hipparcosIds[star.index];\n        const starName = starsData.identStars[hipNumber];\n\n        if (starName) {\n            const textTexture = createTextTexture(starName);\n            const textSprite = createTextSprite(textTexture);\n\n            // Positionnez le sprite à côté du cercle\n            textSprite.position.copy(vertex);\n            textSprite.position.x -= 70;\n            textSprite.position.y -= 70;\n            // Ajoutez le sprite au groupe d'étoiles\n            starGroupRef.current.add(textSprite);\n\n            // Si un sprite précédent a été mis en évidence, retirez-le\n            if (highlightedTextSpriteRef.current) {\n                starGroupRef.current.remove(highlightedTextSpriteRef.current);\n            }\n            highlightedTextSpriteRef.current = textSprite;\n        }\n        else console.log(\"Can't find starname of \" + hipNumber);\n        console.log(\"Star has been highlighted!\");\n    }\n\n\n    useEffect(() => {\n        if (!starsData) return;\n\n        const geometry = new THREE.BufferGeometry();\n        geometry.setAttribute('position', new THREE.Float32BufferAttribute(starsData.vertices, 3));\n        geometry.setAttribute('magnitude', new THREE.Float32BufferAttribute(starsData.magnitudes, 1));\n        geometry.setAttribute('hipparcosId', new THREE.Float32BufferAttribute(starsData.hipparcosIds, 1));\n\n        function createStarTexture() {\n            const canvas = document.createElement('canvas');\n            canvas.width = 64;\n            canvas.height = 64;\n            const ctx = canvas.getContext('2d');\n\n            const gradient = ctx.createRadialGradient(32, 32, 8, 32, 32, 32);\n            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');\n            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');\n\n            ctx.fillStyle = gradient;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n            const texture = new THREE.Texture(canvas);\n            texture.needsUpdate = true;\n            return texture;\n        }\n\n        const shaderMaterial = new THREE.ShaderMaterial({\n            uniforms: {\n                starTexture: { value: createStarTexture() },\n                maxMagnitude: { value: maxShownMagnitude }\n            },\n            vertexShader: `\n                attribute float magnitude;\n                uniform float maxMagnitude;\n                varying float vMagnitude;\n                void main() {\n                    vMagnitude = magnitude;\n                    gl_PointSize = 1.0 + 19.0 * (1.0 - vMagnitude / maxMagnitude);\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }\n            `,\n            fragmentShader: `\n                uniform sampler2D starTexture;\n                uniform float maxMagnitude;\n                varying float vMagnitude;\n                void main() {\n                    if (vMagnitude > maxMagnitude) {\n                        discard;\n                    }\n                    gl_FragColor = texture2D(starTexture, gl_PointCoord);\n                }\n            `,\n            transparent: true,\n            depthTest: true,\n            depthWrite: false,\n            blending: THREE.AdditiveBlending,\n        });\n\n        while (starGroupRef.current.children.length > 0) {\n            starGroupRef.current.remove(starGroupRef.current.children[0]);\n        }\n\n        const points = new THREE.Points(geometry, shaderMaterial);\n        starGroupRef.current.add(points);\n\n        const visibleStarPositions = [];\n\n        for (let i = 0; i < starsData.magnitudes.length; i++) {\n            if (starsData.magnitudes[i] <= maxShownMagnitude) {\n                visibleStarPositions.push(starsData.vertices[i * 3], starsData.vertices[i * 3 + 1], starsData.vertices[i * 3 + 2]);\n            }\n        }\n\n        if (visibleStarPositions.length > 0) {\n            const hitboxMaterial = new THREE.PointsMaterial({ size: 60, transparent: true, opacity: 0 });\n            /*\n            const hitboxMaterial = new THREE.PointsMaterial({\n                size: 60,\n                transparent: true,\n                opacity: 0.5,  // Opacité ajustée pour voir la hitbox\n                color: 0xff0000  // couleur en rouge pour différencier la hitbox\n            });\n            */\n            const hitboxGeometry = new THREE.BufferGeometry();\n            hitboxGeometry.setAttribute('position', new THREE.Float32BufferAttribute(visibleStarPositions, 3));\n            const hitboxes = new THREE.Points(hitboxGeometry, hitboxMaterial);\n            starGroupRef.current.add(hitboxes);\n        }\n\n\n        scene.add(starGroupRef.current);\n\n        return () => {\n            scene.remove(starGroupRef.current);\n        };\n\n\n    }, [starsData, scene, maxShownMagnitude]);\n\n\n    useEffect(() => {\n        function handleKeyDown(event) {\n            // Par exemple, vérifiez si la touche 'D' est pressée :\n            if (event.key === 'd' || event.key === 'D') {\n                setIsDebugEnabled(prev => !prev);  // bascule le mode debug\n            }\n        }\n        window.addEventListener('keydown', handleKeyDown);\n\n        return () => {\n            window.removeEventListener('keydown', handleKeyDown);\n        };\n    }, []);\n\n    function getIntersectionWithSphere(rayOrigin, rayDirection, sphereCenter, sphereRadius) {\n        // Calcul des coefficients a, b et c pour l'équation quadratique\n        const oc = new THREE.Vector3().subVectors(rayOrigin, sphereCenter);\n\n        const a = rayDirection.dot(rayDirection);\n        const b = 2.0 * oc.dot(rayDirection);\n        const c = oc.dot(oc) - sphereRadius * sphereRadius;\n\n        const discriminant = b * b - 4 * a * c;\n\n        if (discriminant < 0) {\n            return null; // Pas d'intersection\n        } else {\n            // On utilise t1 comme point d'intersection car c'est le point le plus proche\n            const t1 = (-b - Math.sqrt(discriminant)) / (2.0 * a);\n            const t2 = (-b + Math.sqrt(discriminant)) / (2.0 * a);\n\n            // Si t1 est négatif, alors le début du rayon est à l'intérieur de la sphère\n            const t = t1 > 0 ? t1 : t2;\n\n            return new THREE.Vector3(\n                rayOrigin.x + t * rayDirection.x,\n                rayOrigin.y + t * rayDirection.y,\n                rayOrigin.z + t * rayDirection.z\n            );\n        }\n    }\n\n\n\n\n    useEffect(() => {\n        function onClick(event) {\n            console.log(\"Clic event \", event)\n            mouse.x = (event.offsetX / gl.domElement.clientWidth) * 2 - 1;\n            mouse.y = -(event.offsetY / gl.domElement.clientHeight) * 2 + 1;\n            raycaster.setFromCamera(mouse, camera);\n\n            if (!rayCasting) {\n                let closestStarIndex = null;\n                let minDistance = Infinity;\n                const rayOrigin = new THREE.Vector3(0, 0, 0);    // Exemple d'origine  \n                const sphereCenter = new THREE.Vector3(0, 0, 0); // Exemple de centre\n                const sphereRadius = 1000;\n\n                console.log(\"Rotation=\", rotation);\n\n                const rotationMatrixX = new THREE.Matrix4().makeRotationX(rotation.x);\n                const rotationMatrixY = new THREE.Matrix4().makeRotationY(rotation.y);\n                \n                // Combine les rotations en multipliant d'abord la rotation Y, puis la rotation X\n                const combinedRotationMatrix = new THREE.Matrix4().multiplyMatrices(rotationMatrixX, rotationMatrixY);\n                \n                // Obtenez la matrice de rotation inverse\n                const inverseRotationMatrix = new THREE.Matrix4().getInverse(combinedRotationMatrix);\n                \n                // Appliquez la rotation inverse à la direction du raycaster pour obtenir la direction ajustée\n                const rotatedDirection = raycaster.ray.direction.clone().applyMatrix4(inverseRotationMatrix);\n                \n                // Utilisez cette direction ajustée pour obtenir le point d'intersection avec la sphère\n                const intersectionPoint = getIntersectionWithSphere(rayOrigin, rotatedDirection.normalize(), sphereCenter, sphereRadius);\n                \n\n\n                if (intersectionPoint) {\n\n                    console.log(`Intersection point: ${intersectionPoint.x}, ${intersectionPoint.y}, ${intersectionPoint.z}`);\n\n                    // Parcourir les étoiles visibles\n                    for (let i = 0; i < starsData.vertices.length / 3; i++) {\n                        if (starsData.magnitudes[i] <= maxShownMagnitude) {\n                            const starPosition = new THREE.Vector3(\n                                starsData.vertices[i * 3],\n                                starsData.vertices[i * 3 + 1],\n                                starsData.vertices[i * 3 + 2]\n                            );\n                            const distance = starPosition.distanceTo(intersectionPoint);\n\n                            if (distance < minDistance) {\n                                minDistance = distance;\n                                closestStarIndex = i;\n                            }\n                        }\n                    }\n\n                    if (closestStarIndex !== null) {\n                        const hipparcosId = starsData.hipparcosIds[closestStarIndex];\n                        console.log(\"Etoile la plus proche Hipparcos ID:\", hipparcosId);\n\n                        // Mettez en surbrillance cette étoile\n                        const star = {\n                            object: {\n                                geometry: {\n                                    attributes: {\n                                        position: new THREE.BufferAttribute(new Float32Array(starsData.vertices), 3),\n                                        hipparcosId: new THREE.BufferAttribute(new Float32Array(starsData.hipparcosIds), 1)\n                                    }\n                                }\n                            },\n                            index: closestStarIndex\n                        };\n                        highlightStar(star);\n                    }\n\n                } else {\n                    console.log(\"No intersection\");\n                }\n            }\n            else {\n                raycaster.far = 1100;\n\n                if (isDebugEnabled) {\n                    addDebugRay();\n                } else {\n                    removeDebugRay();\n                }\n\n                // Filtrer les objets pour ne pas inclure le cercle bleu mis en évidence lors de l'interception\n                const objectsToIntersect = starGroupRef.current.children.filter(obj => obj !== highlightedStarRef.current);\n\n                const intersects = raycaster.intersectObjects(objectsToIntersect, true);\n\n                if (intersects.length > 0) {\n                    console.log(\"Intersect=\", intersects[0])\n                    const star = intersects[0];\n                    const hipparcosIdAttribute = star.object.geometry.attributes.hipparcosId;\n                    const hipparcosId = hipparcosIdAttribute.getX(star.index);\n                    console.log(\"Intercepted Star Hipparcos ID:\", hipparcosId);\n                    highlightStar(star);\n                }\n            }\n        }\n\n        window.addEventListener('click', onClick);\n\n        return () => {\n            window.removeEventListener('click', onClick);\n            removeDebugRay();\n        };\n    }, [rotation, starsData, camera, gl, isDebugEnabled]);\n\n    return null;\n}\n\nexport default Stars;\n","import { useEffect, useRef, useContext } from 'react';\nimport { useThree } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { SkyContext } from '../contexts/Skycontext';\n/**\n * \n * @param {*} param0 \n * @returns \n */\nfunction Constellations({rotation}) {\n    const { scene } = useThree();\n    const { starsData, constellationLines } = useContext(SkyContext);\n\n    // Créez une référence pour le groupe\n    const constellationGroupRef = useRef(new THREE.Group());\n\n    useEffect(() => {\n        constellationGroupRef.current.rotation.y = rotation.y;\n        constellationGroupRef.current.rotation.x = rotation.x;\n    }, [rotation]);\n\n    useEffect(() => {\n        if (!starsData || !constellationLines) return;\n\n        const material = new THREE.LineBasicMaterial({ color: 0xFFFFFF });  // Une ligne blanche pour les constellations\n        constellationLines.forEach(line => {\n            const startStarIndex = starsData.hipToIndex[line.startStar] * 3;\n            const endStarIndex = starsData.hipToIndex[line.endStar] * 3;\n\n            //console.log(\"Start=\" + line.startStar + \" \" + starsData.vertices[startStarIndex] + \",\" + starsData.vertices[startStarIndex + 1] + \",\" + starsData.vertices[startStarIndex + 2]);\n            //console.log(\"End=\" + line.endStar + \" \" + starsData.vertices[endStarIndex] + \",\" + starsData.vertices[endStarIndex + 1] + \",\" + starsData.vertices[endStarIndex + 2]);\n\n            if (starsData.vertices[startStarIndex] !== undefined && starsData.vertices[endStarIndex] !== undefined) {\n                const startStarCoords = new THREE.Vector3(\n                    starsData.vertices[startStarIndex],\n                    starsData.vertices[startStarIndex + 1],\n                    starsData.vertices[startStarIndex + 2]\n                );\n\n                const endStarCoords = new THREE.Vector3(\n                    starsData.vertices[endStarIndex],\n                    starsData.vertices[endStarIndex + 1],\n                    starsData.vertices[endStarIndex + 2]\n                );\n\n                const geometry = new THREE.BufferGeometry().setFromPoints([startStarCoords, endStarCoords]);\n                const line = new THREE.Line(geometry, material);\n                constellationGroupRef.current.add(line);\n            }\n        });\n\n        // Ajoutez le groupe contenant les lignes à la scène\n        scene.add(constellationGroupRef.current);\n\n        return () => {\n            scene.remove(constellationGroupRef.current);\n        };\n\n    }, [starsData, scene, constellationLines]);\n\n    return null;\n}\n\nexport default Constellations;\n","import React, { useState, useEffect,useContext } from 'react';\nimport Stars from './Stars';\nimport Constellations from './Constellations';\nimport { getSiderealTime } from '../utils/astroUtils';\nimport * as THREE from 'three';\nimport { SkyContext } from '../contexts/Skycontext';\n/**\n * \n * @param {*} param0 \n * @returns \n */\nfunction Sky() {\n    const [rotation, setRotation] = useState({ x: 0, y: 0 });\n    const { shownConstellations,representation,location } = useContext(SkyContext);\n\n    useEffect(() => {\n        console.log(\"Changement de representation\")\n        if (representation === 'Equatorial') {\n            setRotation({ x: 0, y: 0 });\n        } else if (representation === 'Horizontal') {\n            const longitude = location.longitude;\n            const latitude = location.latitude;\n            const LST = getSiderealTime(longitude);\n            const LSTinRadians = THREE.MathUtils.degToRad(LST);\n            const inclination = THREE.MathUtils.degToRad(90 - latitude);\n            setRotation({ x: inclination, y: LSTinRadians });\n        }\n    }, [representation, location]);\n\n    return (\n        <>\n            {/* Affiche les étoiles. */}\n            <Stars rotation={rotation} />\n            {/* Affiche les constellations. */}\n            {shownConstellations===\"Oui\" && <Constellations rotation={rotation} />}\n        </>\n    );\n}\n\nexport default Sky;\n","import { degToRad,radToDeg } from \"three/src/math/MathUtils\";\n/**\n * Calcule le temps sidéral local (LST) pour une longitude donnée.\n * \n * @param {number} longitude - La longitude en degrés pour laquelle le temps sidéral sera calculé.\n * @return {number} Le temps sidéral local (LST) en degrés.\n */\nexport function getSiderealTime(longitude) {\n    // Obtener la date et l'heure actuelles\n    const now = new Date();\n\n    // Calculer le nombre de jours écoulés depuis le début du J2000.0\n    const centuryStart = new Date(Date.UTC(2000, 0, 1, 12)); // 1er janvier 2000, 12h UT\n    const daysSinceJ2000 = (now - centuryStart) / (1000 * 60 * 60 * 24);\n\n    // Calculez le temps sidéral vert (GST) en utilisant une formule simplifiée\n    let GST = 280.16 + 360.9856235 * daysSinceJ2000;\n    GST = GST % 360; // Ramenez-le à l'intervalle [0, 360°]\n\n    // Convertir le GST en temps sidéral local (LST) en ajoutant la longitude\n    let LST = GST + longitude;\n    while (LST < 0) LST += 360;\n    while (LST > 360) LST -= 360;\n\n    return LST;\n}\n\n/**\n * Calcule l'heure angulaire d'un astre en fonction du temps sidéral local et de son ascension droite.\n * \n * @param {number} lst - Le temps sidéral local en degrés.\n * @param {number} ra - L'ascension droite de l'astre en degrés.\n * @return {number} L'heure angulaire en degrés.\n */\nfunction calculateHourAngle(lst, ra) {\n    let H = lst - ra;\n\n    // Ajustement pour s'assurer que H est dans l'intervalle [0, 360°] ou [0, -360°].\n    while (H >= 360) {\n        H -= 360;\n    }\n    while (H < 0) {\n        H += 360;\n    }\n\n    return H;\n}\n\n/**\n * Convertit des coordonnées équatoriales à horizontales.\n * \n * @param {number} dec - La déclinaison de l'astre en degrés.\n * @param {number} H - L'heure angulaire en degrés.\n * @param {number} latitude - La latitude de l'observateur en degrés.\n * @return {object} Un objet contenant les coordonnées horizontales : azimut (en degrés) et altitude (en degrés).\n */\nfunction equatorialToHorizontal(dec, H, latitude) {\n    // Calculer l'altitude de l'astre\n    const sinAlt = Math.sin(degToRad(dec)) * Math.sin(degToRad(latitude)) + \n                   Math.cos(degToRad(dec)) * Math.cos(degToRad(latitude)) * Math.cos(degToRad(H));\n    const alt = radToDeg(Math.asin(sinAlt));\n    \n    // Calculer l'azimut de l'astre\n    const cosA = (Math.sin(degToRad(dec)) - Math.sin(degToRad(alt)) * Math.sin(degToRad(latitude))) / \n                 (Math.cos(degToRad(alt)) * Math.cos(degToRad(latitude)));\n    const az = radToDeg(Math.acos(cosA));\n    \n    return { azimuth: az, altitude: alt };\n}\n\n","import React from 'react';\nimport { Canvas } from '@react-three/fiber';\nimport RADECGrid from './RADECGrid';\nimport Horizon from './Horizon';\nimport CameraControls from '../CameraControls';\nimport Sky from './Sky';\n\n/*\nEn ce qui concerne les directions des axes dans Three.js:\n\nL'axe X est dirigé vers la droite.\nL'axe Y est dirigé vers le haut.\nL'axe Z est dirigé en avant, hors de l'écran.\nDonc, dans votre configuration:\n\nL'axe X (rouge dans axesHelper) pointe vers la droite.\nL'axe Y (vert dans axesHelper) pointe vers le haut.\nL'axe Z (bleu dans axesHelper) pointe directement hors de l'écran vers vous.\nLorsque vous utilisez axesHelper, il affiche des lignes représentant ces axes dans ces couleurs. Le rouge est pour X, le vert pour Y, et le bleu pour Z.\n*/\nfunction SkyDome() {\n    return (\n        <Canvas style={{ background: '#001122' }} >\n            <orthographicCamera position={[0, 0, 0]} left={-1500} right={1500} top={1500} bottom={-1500} near={0.1} far={1500} />\n            \n            {/* Afficher le ciel nocturne. */}\n            <Sky />\n\n            {/* Affiche l'horizon. */}\n            <Horizon />\n\n            {/* Affiche la grille RA/DEC. */}\n            <RADECGrid />\n\n            {/* Affiche les aides pour les axes. */}\n            <axesHelper args={[1000]} />\n\n            {/* Éclaire la scène avec une lumière ambiante. */}\n            <ambientLight intensity={0.5} />\n\n            {/* Ajoute une lumière directionnelle pointant vers la position spécifiée. */}\n            <directionalLight position={[0, 0, 5]} intensity={1} />\n\n            {/* Contrôles pour la caméra. */}\n            <CameraControls />\n        </Canvas>\n    );\n}\n\nexport default SkyDome;\n","import React, { Component } from 'react';\n\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Mettez à jour l'état pour que le prochain rendu affiche le remplacement d'UI.\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // Vous pouvez également enregistrer l'erreur dans un service de reporting d'erreurs\n    console.error(\"Uncaught error:\", error, errorInfo);\n    this.setState({ error, errorInfo });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // Vous pouvez rendre n'importe quelle interface utilisateur de remplacement\n      return (\n        <div>\n          <h1>Quelque chose s'est mal passé.</h1>\n          <details style={{ whiteSpace: 'pre-wrap' }}>\n            {this.state.error && this.state.error.toString()}\n            <br />\n            {this.state.errorInfo.componentStack}\n          </details>\n        </div>\n      );\n    }\n\n    // Si il n'y a pas d'erreur, renvoyer les enfants normalement\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;\n","import React, { useContext, useState } from 'react';\nimport './Sidebar.css';\nimport { SkyContext } from '../contexts/Skycontext';\n\nfunction Sidebar() {\n    const { maxShownMagnitude, setMaxShownMagnitude, representation, toggleRepresentation, shownConstellations, toggleShownConstellations } = useContext(SkyContext);\n\n    // Utilisation d'un état local pour suivre la valeur du curseur\n    const [sliderValue, setSliderValue] = useState(maxShownMagnitude);\n\n    const handleSliderChange = (event) => {\n        const newMagnitude = parseFloat(event.target.value);\n        setSliderValue(newMagnitude);\n        setMaxShownMagnitude(newMagnitude);\n    };\n   \n    return (\n        <div className=\"sidebar\">\n            <h2 className=\"representation-title\">{representation}</h2>\n            <button onClick={toggleRepresentation}>Basculer la représentation</button>\n            <h2 className=\"constellations-title\">Constellations: {shownConstellations}</h2>\n            <div\n                className={`toggle-btn ${shownConstellations === 'Oui' ? 'on' : 'off'}`}\n                onClick={toggleShownConstellations}\n            >\n                <div className=\"toggle-indicator\"></div>\n            </div>\n\n            <div className=\"magnitude-slider\">\n                <label>Magnitude maximale affichée: {sliderValue}</label>\n                <input\n                    type=\"range\"\n                    min=\"0\"\n                    max=\"10\"\n                    step=\"0.1\"\n                    value={sliderValue}\n                    onChange={handleSliderChange}\n                />\n            </div>\n        </div>\n    );\n}\n\nexport default Sidebar;\n","// Header.js\nimport React, { useContext } from 'react';\nimport './Header.css';\nimport { SkyContext } from '../contexts/Skycontext';\n\nfunction Header({deviceType}) {\n    const { currentTime, location } = useContext(SkyContext);\n    //console.log(\"Location: \", location)\n\n    const offsetMinutes = currentTime.getTimezoneOffset();\n    const offsetHours = offsetMinutes / 60;\n\n    return (\n        <div className=\"header\">\n          {deviceType !== \"mobile\" && <h1 className=\"header-title\">SkySphereJS</h1>}\n            <div className=\"right-section\">\n                <span className=\"location\">\n                    {location.latitude && location.longitude ?\n                        `Lat: ${location.latitude.toFixed(2)}, Long: ${location.longitude.toFixed(2)}` :\n                        \"Localisation non disponible\"}\n                </span>\n                <span className=\"time\"> {currentTime.toLocaleTimeString()} UTC {offsetHours >= 0 ? '+' : ''}{offsetHours}</span>\n\n            </div>\n        </div>\n    );\n}\n\nexport default Header;\n","import React, { useState, useEffect } from 'react';\nimport './App.css';\nimport SkyDome from './components/SkyDome';\nimport ErrorBoundary from './ErrorBoundary';\nimport Sidebar from './components/Sidebar';\nimport Header from './components/Header';\nimport { SkyProvider } from './contexts/Skycontext';\n\nfunction App() {\n  const [deviceType, setDeviceType] = useState(getDeviceType(window.innerWidth));\n/**\n  * \n  * @param {*} width \n  * @returns \n  */\nfunction getDeviceType(width) {\n  console.log(\"Width=\"+width);\n  if (width < 768) {\n    return 'mobile';\n  } else if (width <= 1180) {\n    return 'tablette';\n  } else {\n    return 'ordinateur';\n  }\n}\nuseEffect(() => {\n  const handleResize = () => {\n    setDeviceType(getDeviceType(window.innerWidth));\n  };\n\n  window.addEventListener('resize', handleResize);\n  return () => {\n    window.removeEventListener('resize', handleResize);\n  };\n}, []);\n\n\n  return (\n    <div className={`App ${deviceType === \"mobile\" ? \"mobile\" : \"\"}`}>\n      <SkyProvider>\n        <ErrorBoundary>\n          <Header deviceType={deviceType} />\n          <div className=\"content\">\n            <SkyDome />\n          </div>\n          {deviceType !== \"mobile\" && <Sidebar />}\n        </ErrorBoundary>\n      </SkyProvider>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n\n\n"],"sourceRoot":""}